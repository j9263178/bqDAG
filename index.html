<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BetonQuest DAG</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 10px;
      line-height: 1.6;
    }
    .container {
      max-width: 1600px;
      margin: 0 auto;
      padding: 0 10px;
    }
    header {
      text-align: center;
      padding: 10px 0;
    }
    .animated-title {
      transition: transform 0.3s ease;
    }
    .animated-title:hover {
      transform: scale(1.1);
    }
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    #graph-container {
      width: 100%;
      height: 700px;
      position: relative;
      margin-top: 10px;
      background: #f8f8f8;
      border-radius: 8px;
      overflow: hidden;
    }
    canvas {
      width: 100%;
      height: 100%;
    }
    .nav-link {
      display: inline-block;
      margin: 10px;
      padding: 8px 15px;
      background: #007bff;
      color: white;
      text-decoration: none;
      border-radius: 20px;
      transition: background-color 0.3s;
    }
    .nav-link:hover {
      background: #0056b3;
    }
    .controls {
      text-align: center;
      margin: 5px 0;
    }
    .mode-button {
      padding: 6px 12px;
      margin: 0 3px;
      border: none;
      border-radius: 20px;
      background: #6c757d;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s;
      font-size: 14px;
    }
    .mode-button.active {
      background: #28a745;
    }
    .mode-button:hover {
      background: #5a6268;
    }
    .mode-button.active:hover {
      background: #218838;
    }
    #edit-panel {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.2);
      z-index: 1000;
      width: 400px;
      max-height: 80vh;
      overflow-y: auto;
    }
    .edit-field {
      margin-bottom: 8px;
    }
    .edit-field label {
      display: block;
      margin-bottom: 4px;
      color: #333;
      font-weight: bold;
      font-size: 14px;
    }
    .edit-field input, .edit-field textarea {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 12px;
      line-height: 1.4;
    }
    .edit-field textarea {
      height: 60px;
      resize: vertical;
    }
    .edit-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 8px;
    }
    .edit-buttons button {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s;
      font-size: 12px;
    }
    .save-button {
      background: #28a745;
      color: white;
    }
    .save-button:hover {
      background: #218838;
    }
    .cancel-button {
      background: #dc3545;
      color: white;
    }
    .cancel-button:hover {
      background: #c82333;
    }
    #overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 999;
    }
    .node-info {
      margin-bottom: 20px;
      padding: 15px;
      background: #f0f0f0;
      border-radius: 6px;
      font-size: 14px;
      border: 1px solid #ddd;
    }
    .node-info h3 {
      margin: 0 0 12px 0;
      color: #333;
      font-size: 16px;
      font-weight: bold;
      border-bottom: 1px solid #ddd;
      padding-bottom: 8px;
    }
    .node-info p {
      margin: 8px 0;
      line-height: 1.4;
    }
    .node-info strong {
      color: #555;
      margin-right: 8px;
    }
    .list-container {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-bottom: 8px;
      padding: 8px;
    }
    .list-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 8px;
      margin: 4px 0;
      background: #f8f8f8;
      border-radius: 4px;
    }
    .list-item button {
      background: #dc3545;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 2px 6px;
      cursor: pointer;
    }
    .list-controls {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }
    .list-controls input {
      flex: 1;
      padding: 4px 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .add-button {
      background: #28a745;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 4px 8px;
      cursor: pointer;
    }
    .list-edit-panel {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.2);
      z-index: 1001;
      width: 500px;
      max-height: 80vh;
      overflow-y: auto;
    }
    .list-edit-panel h3 {
      margin: 0 0 15px 0;
      color: #333;
      font-size: 16px;
    }
    .list-container {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-bottom: 12px;
      padding: 8px;
    }
    #yaml-display-panel {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.2);
      z-index: 1001;
      width: 80%;
      max-width: 800px;
      max-height: 80vh;
    }
    #yaml-content {
      width: 100%;
      height: 400px;
      margin: 10px 0;
      padding: 10px;
      font-family: monospace;
      white-space: pre;
      overflow: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .copy-button {
      background: #007bff;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 10px;
    }
    .copy-button:hover {
      background: #0056b3;
    }
    .yaml-panel {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.2);
      z-index: 1001;
      width: 80%;
      max-width: 800px;
      max-height: 80vh;
      text-align: center;
    }
    .yaml-panel h3 {
      margin: 0 0 15px 0;
      color: #333;
      font-size: 16px;
    }
    .yaml-panel textarea {
      width: calc(100% - 20px);
      height: 400px;
      margin: 10px auto;
      padding: 10px;
      font-family: monospace;
      white-space: pre;
      resize: vertical;
      border: 1px solid #ddd;
      border-radius: 4px;
      display: block;
    }
    .condition-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px;
      margin: 4px 0;
      background: #f5f5f5;
      border-radius: 4px;
    }
    .condition-toggle {
      display: flex;
      gap: 8px;
    }
    .condition-toggle button {
      padding: 4px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s;
      min-width: 80px;
    }
    .condition-toggle button.true {
      background: #4CAF50;
      color: white;
    }
    .condition-toggle button.false {
      background: #f44336;
      color: white;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1 style="font-size: 24px; margin: 5px 0;">BetonQuest DAG</h1>
      <p style="margin: 5px 0;">
        Click canvas to add, drag nodes and create connections! Click nodes in edit mode to edit. Note: black nodes are npc_options, red nodes are player_options.
      </p>
      <div class="controls">
        <button id="addNodeMode" class="mode-button active">Add Node</button>
        <button id="addEdgeMode" class="mode-button">Add Connection</button>
        <button id="editMode" class="mode-button">Edit Mode</button>
        <button id="moveMode" class="mode-button">Move Mode</button>
        <button id="deleteMode" class="mode-button">Delete Mode</button>
        <button id="exportYaml" class="mode-button" style="background: #007bff;">Export YAML</button>
        <button id="importYamlBtn" class="mode-button" style="background: #e6a800;">Import YAML</button>
        <button id="conditionManagerBtn" class="mode-button" style="background: #9c27b0;">Condition Manager</button>
      </div>
    </header>
    <div id="graph-container">
      <canvas id="graphCanvas"></canvas>
    </div>
  </div>

  <div id="overlay"></div>
  <div id="edit-panel">
    <div class="node-info" style="margin-bottom: 20px; padding: 15px; background: #f5f5f5; border-radius: 6px;">
      <h3 style="margin: 0 0 10px 0; color: #333;">Node Information</h3>
      <div id="node-basic-info"></div>
      <div id="node-connections"></div>
    </div>
    <div class="edit-field">
      <label for="edit-id">Node ID:</label>
      <input type="text" id="edit-id" />
    </div>
    <div class="edit-field">
      <label for="edit-text">Text:</label>
      <textarea id="edit-text"></textarea>
    </div>
    <div class="edit-field">
      <label>Conditions List:</label>
      <div id="conditions-list" class="list-container"></div>
      <button id="edit-conditions" class="mode-button">Edit Conditions</button>
    </div>
    <div class="edit-field">
      <label>Events List:</label>
      <div id="events-list" class="list-container"></div>
      <button id="edit-events" class="mode-button">Edit Events</button>
    </div>
    <div class="edit-field">
      <label>Objectives List:</label>
      <div id="objectives-list" class="list-container"></div>
      <button id="edit-objectives" class="mode-button">Edit Objectives</button>
    </div>
    <div class="edit-buttons">
      <button class="save-button" id="save-edit">Save</button>
      <button class="cancel-button" id="cancel-edit">Cancel</button>
    </div>
  </div>

  <div id="conditions-editor" class="list-edit-panel">
    <h3>Edit Conditions List</h3>
    <div id="conditions-edit-list" class="list-container"></div>
    <div class="list-controls">
      <input type="text" id="new-condition" placeholder="Enter new condition" />
      <button id="add-condition" class="add-button">Add Condition</button>
    </div>
    <div class="edit-buttons">
      <button class="save-button" id="save-conditions">Confirm</button>
      <button class="cancel-button" id="cancel-conditions">Cancel</button>
    </div>
  </div>

  <div id="events-editor" class="list-edit-panel">
    <h3>Edit Events List</h3>
    <div id="events-edit-list" class="list-container"></div>
    <div class="list-controls">
      <input type="text" id="new-event" placeholder="Enter new event" />
      <button id="add-event" class="add-button">Add Event</button>
    </div>
    <div class="edit-buttons">
      <button class="save-button" id="save-events">Confirm</button>
      <button class="cancel-button" id="cancel-events">Cancel</button>
    </div>
  </div>

  <div id="objectives-editor" class="list-edit-panel">
    <h3>Edit Objectives List</h3>
    <div id="objectives-edit-list" class="list-container"></div>
    <div class="list-controls">
      <input type="text" id="new-objective" placeholder="Enter new objective" />
      <button id="add-objective" class="add-button">Add Objective</button>
    </div>
    <div class="edit-buttons">
      <button class="save-button" id="save-objectives">Confirm</button>
      <button class="cancel-button" id="cancel-objectives">Cancel</button>
    </div>
  </div>

  <div id="yaml-display-panel">
    <h3>YAML Content</h3>
    <div id="yaml-content"></div>
    <div class="edit-buttons">
      <button class="copy-button" id="copy-yaml">Copy</button>
      <button class="cancel-button" id="close-yaml">Close</button>
    </div>
  </div>

  <div id="yaml-import-panel" class="yaml-panel">
    <h3>Import YAML</h3>
    <textarea id="yaml-import-content" placeholder="Paste YAML content here..."></textarea>
    <div class="edit-buttons">
      <button class="save-button" id="import-yaml-confirm">Import</button>
      <button class="cancel-button" id="import-yaml-cancel">Cancel</button>
    </div>
  </div>

  <div id="condition-manager-panel" class="yaml-panel">
    <h3>Condition Manager</h3>
    <div id="condition-list" class="list-container" style="text-align: left; max-height: 400px;"></div>
    <div class="edit-buttons">
      <button class="cancel-button" id="close-condition-manager">Close</button>
    </div>
  </div>

  <script>
    class Node {
      constructor(x, y, radius, label) {
        this.x = x;
        this.y = y;
        this.radius = 40;
        this.label = label;
        this.color = '#4CAF50';
        this.highlightColor = '#81C784';
        this.isHighlighted = false;
        this.text = '';
        this.conditions = [];
        this.events = [];
        this.objectives = [];
        this.isRed = false;
        this.isReachable = true;
        this.orderNumber = 0;
      }

      draw(ctx) {
        // 當滑鼠移到此節點上，進行放大顯示
        if (this.isHighlighted) {
          const scaleFactor = 1.5;
          const enlargedRadius = this.radius * scaleFactor;
          ctx.beginPath();
          ctx.arc(this.x, this.y, enlargedRadius, 0, Math.PI * 2);
          ctx.fillStyle = this.isRed ? '#ff7070' : '#666666';
          ctx.fill();
          ctx.closePath();
        
          // 繪製 label
          ctx.font = `bold ${18 * scaleFactor}px Arial`;
          ctx.fillStyle = 'black';  // 使用黑色文字
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(this.label, this.x, this.y - enlargedRadius / 2);
        
          // 繪製完整的 text（若有多行則逐行顯示）
          if (this.text) {
            ctx.font = `${12 * scaleFactor}px Arial`;
            ctx.fillStyle = 'black';  // 同樣使用黑色
            const lines = this.text.split('\n');
            for (let i = 0; i < lines.length; i++) {
              ctx.fillText(lines[i], this.x, this.y + enlargedRadius / 2 + i * (14 * scaleFactor));
            }
          }
        } else {
          // 非 hover 狀態下的繪製邏輯保持不變
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          if (!this.isReachable) {
            ctx.fillStyle = this.isRed ? '#A57777' : '#888888';
          } else {
            ctx.fillStyle = this.isRed ? '#ff0000' : '#000000';
          }
          ctx.fill();
          ctx.closePath();
        
          ctx.font = 'bold 18px Arial';
          ctx.fillStyle = 'white';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          const displayLabel = this.label.length > 5 ? this.label.substring(0, 5) + '...' : this.label;
          ctx.fillText(displayLabel, this.x, this.y - 8);
        
          if (this.text) {
            ctx.font = '300 12px Arial';
            const previewText = this.text.substring(0, 10) + (this.text.length > 10 ? '...' : '');
            const textWidth = ctx.measureText(previewText).width;
            const maxWidth = this.radius * 2;
            if (textWidth > maxWidth) {
              const halfText = previewText.substring(0, Math.floor(previewText.length / 2));
              const remainingText = previewText.substring(Math.floor(previewText.length / 2));
              ctx.fillText(halfText, this.x, this.y + 8);
              ctx.fillText(remainingText, this.x, this.y + 20);
            } else {
              ctx.fillText(previewText, this.x, this.y + 12);
            }
          }
        }        
      }

      drawHoverInfo(ctx) {
        // 原本的懸停信息框可以移除或保留
        if (this.conditions.length === 0 && this.events.length === 0 && this.objectives.length === 0) {
          return;
        }
        const padding = 10;
        const lineHeight = 20;
        ctx.font = '14px Arial';
        const maxWidth = Math.max(
          ctx.measureText('Conditions:').width,
          ctx.measureText('Events:').width,
          ctx.measureText('Objectives:').width,
          ...this.conditions.map(c => ctx.measureText(c).width),
          ...this.events.map(e => ctx.measureText(e).width),
          ...this.objectives.map(o => ctx.measureText(o).width)
        );
        const boxWidth = maxWidth + padding * 3;
        const totalItems = this.conditions.length + this.events.length + this.objectives.length;
        const boxHeight = (totalItems + 3) * lineHeight + padding * 2;
        let boxX = this.x + this.radius + padding;
        let boxY = this.y - boxHeight - padding;
        if (boxX + boxWidth > ctx.canvas.width) {
          boxX = this.x - boxWidth - this.radius - padding;
        }
        if (boxY < 0) {
          boxY = this.y + this.radius + padding;
        }
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
        ctx.font = '14px Arial';
        ctx.fillStyle = 'white';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        let currentY = boxY + padding;
        if (this.conditions.length > 0) {
          ctx.fillText('Conditions:', boxX + padding, currentY);
          currentY += lineHeight;
          this.conditions.forEach(condition => {
            ctx.fillText(condition, boxX + padding * 2, currentY);
            currentY += lineHeight;
          });
        }
        if (this.events.length > 0) {
          ctx.fillText('Events:', boxX + padding, currentY);
          currentY += lineHeight;
          this.events.forEach(event => {
            ctx.fillText(event, boxX + padding * 2, currentY);
            currentY += lineHeight;
          });
        }
        if (this.objectives.length > 0) {
          ctx.fillText('Objectives:', boxX + padding, currentY);
          currentY += lineHeight;
          this.objectives.forEach(objective => {
            ctx.fillText(objective, boxX + padding * 2, currentY);
            currentY += lineHeight;
          });
        }
      }

      isPointInside(x, y) {
        const dx = this.x - x;
        const dy = this.y - y;
        return Math.sqrt(dx * dx + dy * dy) <= this.radius;
      }
    }

    class Edge {
      constructor(startNode, endNode) {
        this.startNode = startNode;
        this.endNode = endNode;
        this.color = '#2196F3';
        this.highlightColor = '#64B5F6';
        this.isHighlighted = false;
      }

      draw(ctx) {
        const headLength = 15;
        const angle = Math.atan2(this.endNode.y - this.startNode.y, this.endNode.x - this.startNode.x);
        const endX = this.endNode.x - (this.endNode.radius + 5) * Math.cos(angle);
        const endY = this.endNode.y - (this.endNode.radius + 5) * Math.sin(angle);
        const startX = this.startNode.x + (this.startNode.radius + 5) * Math.cos(angle);
        const startY = this.startNode.y + (this.startNode.radius + 5) * Math.sin(angle);
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.strokeStyle = this.isHighlighted ? this.highlightColor : this.color;
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(endX, endY);
        ctx.lineTo(
          endX - headLength * Math.cos(angle - Math.PI / 6),
          endY - headLength * Math.sin(angle - Math.PI / 6)
        );
        ctx.lineTo(
          endX - headLength * Math.cos(angle + Math.PI / 6),
          endY - headLength * Math.sin(angle + Math.PI / 6)
        );
        ctx.closePath();
        ctx.fillStyle = this.isHighlighted ? this.highlightColor : this.color;
        ctx.fill();
      }

      isPointNear(x, y, threshold = 5) {
        const startX = this.startNode.x;
        const startY = this.startNode.y;
        const endX = this.endNode.x;
        const endY = this.endNode.y;
        const A = x - startX;
        const B = y - startY;
        const C = endX - startX;
        const D = endY - startY;
        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if (len_sq !== 0) {
          param = dot / len_sq;
        }
        let xx, yy;
        if (param < 0) {
          xx = startX;
          yy = startY;
        } else if (param > 1) {
          xx = endX;
          yy = endY;
        } else {
          xx = startX + param * C;
          yy = startY + param * D;
        }
        const dx = x - xx;
        const dy = y - yy;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance <= threshold;
      }
    }

    document.addEventListener('DOMContentLoaded', function () {
      let panX = 0, panY = 0;           // 全局平移 (初始時可以設為畫布寬高的一半，讓原點在中間)
      let isPanning = false;
      let panStartX = 0, panStartY = 0;  // 滑鼠拖動起始位置
      let initialPanX = 0, initialPanY = 0;  // 拖動開始時的 offset 值

      const canvas = document.getElementById('graphCanvas');
      const ctx = canvas.getContext('2d');
      const nodes = [];
      const edges = [];
      let nextNodeLabel = 1;
      let selectedNode = null;
      let draggedNode = null;
      let mode = 'addNode';
      let startNode = null;

      const editPanel = document.getElementById('edit-panel');
      const overlay = document.getElementById('overlay');
      const editText = document.getElementById('edit-text');
      const editId = document.getElementById('edit-id');
      let currentEditingNode = null;

      let tempConditions = [];
      let tempEvents = [];
      let tempObjectives = [];

      const globalConditions = new Set();
      const globalEvents = new Set();
      const globalObjectives = new Set();

      const conditionStates = new Map();

      function showEditPanel(node) {
        currentEditingNode = node;
        const nodeInfoDiv = document.getElementById('node-basic-info');
        nodeInfoDiv.innerHTML = `
          <p><strong>Current ID:</strong>${node.label}</p>
          <p><strong>Node Color:</strong>${node.isRed ? 'Red' : 'Black'}</p>
          <p><strong>Order Number:</strong>${node.orderNumber > 0 ? '#' + node.orderNumber : 'None'}</p>
        `;
        const connectionsDiv = document.getElementById('node-connections');
        const outgoingNodes = edges
          .filter(edge => edge.startNode === node)
          .map(edge => edge.endNode.label)
          .join(', ');
        connectionsDiv.innerHTML = `<p><strong>Points to:</strong>${outgoingNodes || 'None'}</p>`;
        editId.value = node.label || '';
        editText.value = node.text || '';
        updateConditionsList(node.conditions);
        updateEventsList(node.events);
        updateObjectivesList(node.objectives);
        editPanel.style.display = 'block';
        overlay.style.display = 'block';
      }

      function hideEditPanel() {
        editPanel.style.display = 'none';
        overlay.style.display = 'none';
        currentEditingNode = null;
      }

      function updateConditionsList(conditions) {
        const container = document.getElementById('conditions-list');
        container.innerHTML = conditions.map(condition => `
          <div class="list-item">
            <span>${condition}</span>
          </div>
        `).join('');
      }

      function updateEventsList(events) {
        const container = document.getElementById('events-list');
        container.innerHTML = events.map(event => `
          <div class="list-item">
            <span>${event}</span>
          </div>
        `).join('');
      }

      function updateObjectivesList(objectives) {
        const container = document.getElementById('objectives-list');
        container.innerHTML = objectives.map(objective => `
          <div class="list-item">
            <span>${objective}</span>
          </div>
        `).join('');
      }

      function showConditionsEditor() {
        if (currentEditingNode) {
          tempConditions = [...currentEditingNode.conditions];
          updateConditionsEditList();
          document.getElementById('conditions-editor').style.display = 'block';
        }
      }

      function showEventsEditor() {
        if (currentEditingNode) {
          tempEvents = [...currentEditingNode.events];
          updateEventsEditList();
          document.getElementById('events-editor').style.display = 'block';
        }
      }

      function showObjectivesEditor() {
        if (currentEditingNode) {
          tempObjectives = [...currentEditingNode.objectives];
          updateObjectivesEditList();
          document.getElementById('objectives-editor').style.display = 'block';
        }
      }

      function updateConditionsEditList() {
        const container = document.getElementById('conditions-edit-list');
        container.innerHTML = tempConditions.map((condition, index) => `
          <div class="list-item">
            <span>${condition}</span>
            <button class="delete-condition" data-index="${index}">刪除</button>
          </div>
        `).join('');
      }

      function updateEventsEditList() {
        const container = document.getElementById('events-edit-list');
        container.innerHTML = tempEvents.map((event, index) => `
          <div class="list-item">
            <span>${event}</span>
            <button class="delete-event" data-index="${index}">刪除</button>
          </div>
        `).join('');
      }

      function updateObjectivesEditList() {
        const container = document.getElementById('objectives-edit-list');
        container.innerHTML = tempObjectives.map((objective, index) => `
          <div class="list-item">
            <span>${objective}</span>
            <button class="delete-objective" data-index="${index}">刪除</button>
          </div>
        `).join('');
      }

      document.getElementById('conditions-edit-list').addEventListener('click', (e) => {
        if (e.target.classList.contains('delete-condition')) {
          const index = parseInt(e.target.dataset.index);
          tempConditions.splice(index, 1);
          updateConditionsEditList();
        }
      });

      document.getElementById('events-edit-list').addEventListener('click', (e) => {
        if (e.target.classList.contains('delete-event')) {
          const index = parseInt(e.target.dataset.index);
          tempEvents.splice(index, 1);
          updateEventsEditList();
        }
      });

      document.getElementById('objectives-edit-list').addEventListener('click', (e) => {
        if (e.target.classList.contains('delete-objective')) {
          const index = parseInt(e.target.dataset.index);
          tempObjectives.splice(index, 1);
          updateObjectivesEditList();
        }
      });

      document.getElementById('save-edit').addEventListener('click', () => {
        if (currentEditingNode) {
          const newId = editId.value.trim();
          const idExists = nodes.some(node => node !== currentEditingNode && node.label === newId);
          if (idExists) {
            alert('This ID is already in use, please use a different ID!');
            return;
          }
          currentEditingNode.label = newId;
          currentEditingNode.text = editText.value;
          const numId = parseInt(newId);
          if (!isNaN(numId)) {
            nextNodeLabel = Math.max(nextNodeLabel, numId + 1);
          }
          hideEditPanel();
          redraw();
        }
      });

      document.getElementById('cancel-edit').addEventListener('click', hideEditPanel);

      const addNodeButton = document.getElementById('addNodeMode');
      const addEdgeButton = document.getElementById('addEdgeMode');
      const editButton = document.getElementById('editMode');
      const moveButton = document.getElementById('moveMode');
      const deleteButton = document.getElementById('deleteMode');
      const exportButton = document.getElementById('exportYaml');
      const importYamlBtn = document.getElementById('importYamlBtn');
      const conditionManagerBtn = document.getElementById('conditionManagerBtn');
      let isDragging = false;
      let dragStartX = 0;
      let dragStartY = 0;

      function setMode(newMode) {
        mode = newMode;
        addNodeButton.classList.toggle('active', mode === 'addNode');
        addEdgeButton.classList.toggle('active', mode === 'addEdge');
        editButton.classList.toggle('active', mode === 'edit');
        moveButton.classList.toggle('active', mode === 'move');
        deleteButton.classList.toggle('active', mode === 'delete');
        startNode = null;
        selectedNode = null;
        draggedNode = null;
        redraw();
        if (mode === 'edit') {
          canvas.style.cursor = 'pointer';
        } else if (mode === 'move') {
          canvas.style.cursor = 'grab';
        } else {
          canvas.style.cursor = 'default';
        }
      }

      addNodeButton.addEventListener('click', () => setMode('addNode'));
      addEdgeButton.addEventListener('click', () => setMode('addEdge'));
      editButton.addEventListener('click', () => setMode('edit'));
      moveButton.addEventListener('click', () => setMode('move'));
      deleteButton.addEventListener('click', () => setMode('delete'));
      conditionManagerBtn.addEventListener('click', () => setMode('conditionManager'));

      function resizeCanvas() {
        const container = document.getElementById('graph-container');
        canvas.width = container.offsetWidth;
        canvas.height = container.offsetHeight;
        // 若尚未設定過，將平移值設在中心
        if(panX === 0 && panY === 0){
          panX = canvas.width / 2;
          panY = canvas.height / 2;
        }
      }

      // 新增一個碰撞檢測函式，防止節點重疊
      function resolveCollisions() {
        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            const nodeA = nodes[i];
            const nodeB = nodes[j];
            let dx = nodeB.x - nodeA.x;
            let dy = nodeB.y - nodeA.y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            // 如果該節點正在被放大，則採用放大後的半徑
            const radiusA = nodeA.isHighlighted ? nodeA.radius * 1.5 : nodeA.radius;
            const radiusB = nodeB.isHighlighted ? nodeB.radius * 1.5 : nodeB.radius;
            const minDist = radiusA + radiusB + 10;
            if (distance < minDist && distance > 0) {
              const overlap = (minDist - distance) / 2;
              const offsetX = (dx / distance) * overlap;
              const offsetY = (dy / distance) * overlap;
              // 若其中一個節點正在被拖曳，則只移動另一個節點
              if (nodeA === draggedNode && nodeB !== draggedNode) {
                nodeB.x += offsetX * 2;
                nodeB.y += offsetY * 2;
              } else if (nodeB === draggedNode && nodeA !== draggedNode) {
                nodeA.x -= offsetX * 2;
                nodeA.y -= offsetY * 2;
              } else {
                nodeA.x -= offsetX;
                nodeA.y -= offsetY;
                nodeB.x += offsetX;
                nodeB.y += offsetY;
              }
            }
          }
        }
      }

      function redraw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(panX, panY);
        updateNodeReachability();
        resolveCollisions();
        edges.forEach(edge => edge.draw(ctx));
        nodes.forEach(node => node.draw(ctx));
        // 如果節點被 hover，則額外繪製提示框（詳見下方說明）
        nodes.forEach(node => { if (node.isHighlighted) node.drawHoverInfo(ctx); });
        ctx.restore();
      }
      
      function getNodeAtPosition(x, y) {
        const worldX = x - panX;
        const worldY = y - panY;
        return nodes.find(node => node.isPointInside(worldX, worldY));
      }
      

      function getEdgeAtPosition(x, y) {
        return edges.find(edge => edge.isPointNear(x, y));
      }

      function updateNodeColors() {
        nodes.forEach(node => {
          node.isRed = false;
        });
        edges.forEach(edge => {
          if (!edge.startNode.isRed) {
            edge.endNode.isRed = true;
          }
        });
        edges.forEach(edge => {
          if (edge.startNode.isRed) {
            edge.endNode.isRed = false;
          }
        });
        redraw();
      }

      function generateYaml() {
        let yaml = '';
        const allConditions = new Set();
        const allEvents = new Set();
        const allObjectives = new Set();
        nodes.forEach(node => {
          node.conditions.forEach(condition => {
            allConditions.add(condition);
            globalConditions.add(condition);
          });
          node.events.forEach(event => {
            allEvents.add(event);
            globalEvents.add(event);
          });
          node.objectives.forEach(objective => {
            allObjectives.add(objective);
            globalObjectives.add(objective);
          });
        });
        if (allConditions.size > 0) {
          yaml += 'conditions:\n';
          Array.from(allConditions).sort().forEach(condition => {
            yaml += `    ${condition}:\n`;
          });
          yaml += '\n';
        }
        if (allEvents.size > 0) {
          yaml += 'events:\n';
          Array.from(allEvents).sort().forEach(event => {
            yaml += `    ${event}:\n`;
          });
          yaml += '\n';
        }
        if (allObjectives.size > 0) {
          yaml += 'objectives:\n';
          Array.from(allObjectives).sort().forEach(objective => {
            yaml += `    ${objective}:\n`;
          });
          yaml += '\n';
        }
        const targetedNodes = new Set(edges.map(edge => edge.endNode.label));
        const firstNodes = nodes
          .filter(node => !targetedNodes.has(node.label))
          .map(node => node.label)
          .sort();
        if (firstNodes.length > 0) {
          yaml += `first: '${firstNodes.join(',')}'\n\n`;
        }
        const npcNodes = nodes.filter(node => !node.isRed);
        const playerNodes = nodes.filter(node => node.isRed);
        yaml += 'NPC_options:\n';
        npcNodes.forEach(node => {
          yaml += `  ${node.label}:\n`;
          if (node.text) {
            if (!node.text.includes('\n')) {
              yaml += `    text: '${node.text}'\n`;
            } else {
              yaml += `    text: |-\n`;
              const lines = node.text.split('\n');
              lines.forEach(line => {
                yaml += `      ${line}\n`;
              });
            }
          }
          if (node.conditions.length > 0) {
            yaml += `    conditions: '${node.conditions.join(',')}'\n`;
          }
          if (node.events.length > 0) {
            yaml += `    events: '${node.events.join(',')}'\n`;
          }
          if (node.objectives.length > 0) {
            yaml += `    objectives: '${node.objectives.join(',')}'\n`;
          }
          const pointers = edges
            .filter(edge => edge.startNode === node)
            .map(edge => edge.endNode.label);
          if (pointers.length > 0) {
            yaml += `    pointer: '${pointers.join(',')}'\n`;
          }
        });
        yaml += '\nplayer_options:\n';
        playerNodes.forEach(node => {
          yaml += `  ${node.label}:\n`;
          if (node.text) {
            if (!node.text.includes('\n')) {
              yaml += `    text: '${node.text}'\n`;
            } else {
              yaml += `    text: |-\n`;
              const lines = node.text.split('\n');
              lines.forEach(line => {
                yaml += `      ${line}\n`;
              });
            }
          }
          if (node.conditions.length > 0) {
            yaml += `    conditions: '${node.conditions.join(',')}'\n`;
          }
          if (node.events.length > 0) {
            yaml += `    events: '${node.events.join(',')}'\n`;
          }
          if (node.objectives.length > 0) {
            yaml += `    objectives: '${node.objectives.join(',')}'\n`;
          }
          const pointers = edges
            .filter(edge => edge.startNode === node)
            .map(edge => edge.endNode.label);
          if (pointers.length > 0) {
            yaml += `    pointer: '${pointers.join(',')}'\n`;
          }
        });
        const yamlContent = document.getElementById('yaml-content');
        yamlContent.textContent = yaml;
        document.getElementById('yaml-display-panel').style.display = 'block';
        document.getElementById('overlay').style.display = 'block';
      }

      function parseYamlContent(content) {
        try {
          const lines = content.split('\n');
          const nodes = new Map();
          const connections = [];
          let currentNode = null;
          let currentSection = null;
          let isReadingText = false;
          let currentText = [];
          globalConditions.clear();
          globalEvents.clear();
          globalObjectives.clear();
          conditionStates.clear();
          for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
            try {
              const line = lines[lineIndex];
              const trimmedLine = line.trim();
              if (trimmedLine === 'conditions:') {
                if (isReadingText && currentText.length > 0 && currentNode) {
                  nodes.get(currentNode).text = currentText.join('\n');
                  isReadingText = false;
                  currentText = [];
                }
                currentSection = 'conditions';
                continue;
              } else if (trimmedLine === 'events:') {
                if (isReadingText && currentText.length > 0 && currentNode) {
                  nodes.get(currentNode).text = currentText.join('\n');
                  isReadingText = false;
                  currentText = [];
                }
                currentSection = 'events';
                continue;
              } else if (trimmedLine === 'objectives:') {
                if (isReadingText && currentText.length > 0 && currentNode) {
                  nodes.get(currentNode).text = currentText.join('\n');
                  isReadingText = false;
                  currentText = [];
                }
                currentSection = 'objectives';
                continue;
              } else if (currentSection === 'conditions' && trimmedLine.endsWith(':')) {
                const condition = trimmedLine.slice(0, -1).trim();
                if (!condition) {
                  throw new Error('條件名稱不能為空');
                }
                globalConditions.add(condition);
              } else if (currentSection === 'events' && trimmedLine.endsWith(':')) {
                const event = trimmedLine.slice(0, -1).trim();
                if (!event) {
                  throw new Error('事件名稱不能為空');
                }
                globalEvents.add(event);
              } else if (currentSection === 'objectives' && trimmedLine.endsWith(':')) {
                const objective = trimmedLine.slice(0, -1).trim();
                if (!objective) {
                  throw new Error('目標名稱不能為空');
                }
                globalObjectives.add(objective);
              } else if (trimmedLine.startsWith('first:')) {
                if (isReadingText && currentText.length > 0 && currentNode) {
                  nodes.get(currentNode).text = currentText.join('\n');
                  isReadingText = false;
                  currentText = [];
                }
                const match = trimmedLine.match(/first:\s*'?([^']*)'?$/);
                if (!match) {
                  throw new Error('first 節點格式錯誤');
                }
                const firstValue = match[1];
                if (firstValue) {
                  firstValue.split(',').forEach(nodeId => {
                    if (!nodeId.trim()) {
                      throw new Error('first 節點ID不能為空');
                    }
                    if (!nodes.has(nodeId)) {
                      nodes.set(nodeId, {
                        text: '',
                        conditions: [],
                        events: [],
                        pointers: []
                      });
                    }
                  });
                }
              } else if (trimmedLine === 'NPC_options:') {
                if (isReadingText && currentText.length > 0 && currentNode) {
                  nodes.get(currentNode).text = currentText.join('\n');
                  isReadingText = false;
                  currentText = [];
                }
                currentSection = 'NPC_options';
                isReadingText = false;
              } else if (trimmedLine === 'player_options:') {
                if (isReadingText && currentText.length > 0 && currentNode) {
                  nodes.get(currentNode).text = currentText.join('\n');
                  isReadingText = false;
                  currentText = [];
                }
                currentSection = 'player_options';
                isReadingText = false;
              } else if (trimmedLine.match(/^[^:]+:$/)) {
                if (isReadingText && currentText.length > 0 && currentNode) {
                  nodes.get(currentNode).text = currentText.join('\n');
                  isReadingText = false;
                  currentText = [];
                }
                if (!currentSection) {
                  throw new Error('節點必須在 NPC_options 或 player_options 區塊內');
                }
                currentNode = trimmedLine.slice(0, -1);
                if (!currentNode.trim()) {
                  throw new Error('節點ID不能為空');
                }
                if (!nodes.has(currentNode)) {
                  nodes.set(currentNode, {
                    text: '',
                    conditions: [],
                    events: [],
                    pointers: []
                  });
                }
                isReadingText = false;
                currentText = [];
              } else if (trimmedLine.startsWith('text:')) {
                if (!currentNode) {
                  throw new Error('text 必須在節點定義內');
                }
                if (trimmedLine === 'text: |-') {
                  isReadingText = true;
                  currentText = [];
                } else {
                  const singleLineMatch = trimmedLine.match(/^text:\s*'?([^']*)'?$/);
                  if (singleLineMatch) {
                    nodes.get(currentNode).text = singleLineMatch[1];
                    isReadingText = false;
                    currentText = [];
                  } else {
                    throw new Error('text 格式錯誤，應為：text: \'內容\' 或 text: |-');
                  }
                }
              } else if (trimmedLine.startsWith('conditions:')) {
                if (isReadingText && currentText.length > 0 && currentNode) {
                  nodes.get(currentNode).text = currentText.join('\n');
                  isReadingText = false;
                  currentText = [];
                }
                if (!currentNode) {
                  throw new Error('conditions 必須在節點定義內');
                }
                const match = trimmedLine.match(/conditions:\s*'?([^']*)'?$/);
                if (!match) {
                  throw new Error('conditions 格式錯誤');
                }
                const conditionsStr = match[1];
                if (conditionsStr) {
                  nodes.get(currentNode).conditions = conditionsStr.split(',');
                }
              } else if (trimmedLine.startsWith('events:')) {
                if (isReadingText && currentText.length > 0 && currentNode) {
                  nodes.get(currentNode).text = currentText.join('\n');
                  isReadingText = false;
                  currentText = [];
                }
                if (!currentNode) {
                  throw new Error('events 必須在節點定義內');
                }
                const match = trimmedLine.match(/events:\s*'?([^']*)'?$/);
                if (!match) {
                  throw new Error('events 格式錯誤');
                }
                const eventsStr = match[1];
                if (eventsStr) {
                  nodes.get(currentNode).events = eventsStr.split(',');
                }
              } else if (trimmedLine.startsWith('objectives:')) {
                if (isReadingText && currentText.length > 0 && currentNode) {
                  nodes.get(currentNode).text = currentText.join('\n');
                  isReadingText = false;
                  currentText = [];
                }
                if (!currentNode) {
                  throw new Error('objectives 必須在節點定義內');
                }
                const match = trimmedLine.match(/objectives:\s*'?([^']*)'?$/);
                if (!match) {
                  throw new Error('objectives 格式錯誤');
                }
                const objectivesStr = match[1];
                if (objectivesStr) {
                  nodes.get(currentNode).objectives = objectivesStr.split(',');
                }
              } else if (trimmedLine.startsWith('pointer:')) {
                if (isReadingText && currentText.length > 0 && currentNode) {
                  nodes.get(currentNode).text = currentText.join('\n');
                  isReadingText = false;
                  currentText = [];
                }
                if (!currentNode) {
                  throw new Error('pointer 必須在節點定義內');
                }
                const match = trimmedLine.match(/pointer:\s*'?([^']*)'?$/);
                if (!match) {
                  throw new Error('pointer 格式錯誤');
                }
                const pointerStr = match[1];
                if (pointerStr) {
                  const pointers = pointerStr.split(',');
                  nodes.get(currentNode).pointers = pointers;
                  pointers.forEach(pointer => {
                    if (!pointer.trim()) {
                      throw new Error('pointer 不能包含空值');
                    }
                    connections.push([currentNode, pointer]);
                  });
                }
              } else if (isReadingText && line.startsWith('      ')) {
                currentText.push(line.substring(6));
              } else if (isReadingText && currentText.length > 0 &&
                (!lines[lineIndex + 1] ||
                  (!lines[lineIndex + 1].startsWith('      ') && lines[lineIndex + 1].trim()))) {
                nodes.get(currentNode).text = currentText.join('\n');
                isReadingText = false;
                currentText = [];
              } else if (lineIndex === lines.length - 1 && isReadingText && currentText.length > 0 && currentNode) {
                nodes.get(currentNode).text = currentText.join('\n');
                isReadingText = false;
              }
            } catch (error) {
              throw new Error(`第 ${lineIndex + 1} 行出錯：${error.message}\n問題行內容：${lines[lineIndex]}`);
            }
          }
          return { nodes, connections };
        } catch (error) {
          alert(error.message);
          console.error('YAML解析錯誤:', error);
          return null;
        }
      }

      function importYaml(content) {
        const data = parseYamlContent(content);
        if (!data) {
          alert('YAML格式錯誤！');
          return;
        }
        nodes.length = 0;
        edges.length = 0;
        const sortedNodes = Array.from(data.nodes.entries()).sort((a, b) => {
          const textA = a[1].text || '';
          const textB = b[1].text || '';
          return textA.localeCompare(textB, 'zh-TW');
        });
        sortedNodes.forEach(([nodeId, nodeData], index) => {
          const node = new Node(0, 0, 40, nodeId);
          node.text = nodeData.text;
          node.conditions = nodeData.conditions;
          node.events = nodeData.events;
          node.orderNumber = index + 1;
          nodes.push(node);
        });
        data.connections.forEach(([fromId, toId]) => {
          const startNode = nodes.find(n => n.label === fromId);
          const endNode = nodes.find(n => n.label === toId);
          if (startNode && endNode) {
            edges.push(new Edge(startNode, endNode));
          }
        });
        const targetedNodes = new Set(edges.map(edge => edge.endNode.label));
        const rootNodes = nodes.filter(node => !targetedNodes.has(node.label));
        const nodeLevels = new Map();
        const calculateLevels = (node, level) => {
          if (nodeLevels.has(node)) {
            return;
          }
          nodeLevels.set(node, level);
          const children = edges
            .filter(edge => edge.startNode === node)
            .map(edge => edge.endNode);
          children.forEach(child => calculateLevels(child, level + 1));
        };
        rootNodes.forEach(node => calculateLevels(node, 0));
        const levelGroups = new Map();
        nodeLevels.forEach((level, node) => {
          if (!levelGroups.has(level)) {
            levelGroups.set(level, []);
          }
          levelGroups.get(level).push(node);
        });
        const maxLevel = Math.max(...nodeLevels.values());
        const maxNodesInLevel = Math.max(...Array.from(levelGroups.values()).map(group => group.length));
        const levelSpacing = canvas.width / (maxLevel + 2);
        const nodeSpacing = canvas.height / (maxNodesInLevel + 1);
        const startX = levelSpacing;
        levelGroups.forEach((nodesInLevel, level) => {
          const levelX = startX + level * levelSpacing;
          const totalHeight = (nodesInLevel.length - 1) * nodeSpacing;
          const startY = (canvas.height - totalHeight) / 2;
          nodesInLevel.forEach((node, index) => {
            node.x = levelX;
            node.y = startY + index * nodeSpacing;
          });
        });
        updateNodeColors();
        nodes.forEach(node => {
          node.conditions.forEach(condition => {
            const actualCondition = condition.startsWith('!') ? condition.substring(1) : condition;
            globalConditions.add(actualCondition);
            if (!conditionStates.has(actualCondition)) {
              conditionStates.set(actualCondition, false);
            }
          });
        });
        updateNodeReachability();
        redraw();
        updateConditionManagerPanel();
        nextNodeLabel = Math.max(...Array.from(data.nodes.keys()).map(id => parseInt(id) || 0)) + 1;
      }

      document.getElementById('importYamlBtn').addEventListener('click', () => {
        document.getElementById('yaml-import-panel').style.display = 'block';
        document.getElementById('overlay').style.display = 'block';
        document.getElementById('yaml-import-content').value = '';
      });

      document.getElementById('import-yaml-confirm').addEventListener('click', () => {
        const content = document.getElementById('yaml-import-content').value;
        if (content.trim()) {
          importYaml(content);
          document.getElementById('yaml-import-panel').style.display = 'none';
          document.getElementById('overlay').style.display = 'none';
        } else {
          alert('Please paste YAML content first!');
        }
      });

      document.getElementById('import-yaml-cancel').addEventListener('click', () => {
        document.getElementById('yaml-import-panel').style.display = 'none';
        document.getElementById('overlay').style.display = 'none';
      });

      exportButton.addEventListener('click', generateYaml);

      canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const worldX = x - panX;
        const worldY = y - panY;
        const clickedNode = getNodeAtPosition(x, y);
        if (!clickedNode) {  // 若沒點到節點，啟動畫布拖動
          isPanning = true;
          panStartX = e.clientX;
          panStartY = e.clientY;
          initialPanX = panX;
          initialPanY = panY;
          return;
        }
        if (mode === 'addNode') {
          const worldX = x - panX;
          const worldY = y - panY;
          const node = new Node(worldX, worldY, 40, nextNodeLabel.toString());
          nodes.push(node);
          nextNodeLabel++;
          updateNodeColors();
        } else if (mode === 'addEdge') {
          const clickedNode = getNodeAtPosition(x, y);
          if (clickedNode) {
            if (!startNode) {
              startNode = clickedNode;
              startNode.isHighlighted = true;
            } else if (startNode !== clickedNode) {
              const edgeExists = edges.some(edge =>
                edge.startNode === startNode && edge.endNode === clickedNode
              );
              if (!edgeExists) {
                edges.push(new Edge(startNode, clickedNode));
                updateNodeColors();
              }
              startNode.isHighlighted = false;
              startNode = null;
            }
            redraw();
          }
        } else if (mode === 'delete') {
          const clickedNode = getNodeAtPosition(x, y);
          if (clickedNode) {
            const nodeIndex = nodes.indexOf(clickedNode);
            if (nodeIndex > -1) {
              nodes.splice(nodeIndex, 1);
              for (let i = edges.length - 1; i >= 0; i--) {
                if (edges[i].startNode === clickedNode || edges[i].endNode === clickedNode) {
                  edges.splice(i, 1);
                }
              }
              updateNodeColors();
            }
          } else {
            const clickedEdge = getEdgeAtPosition(x, y);
            if (clickedEdge) {
              const edgeIndex = edges.indexOf(clickedEdge);
              if (edgeIndex > -1) {
                edges.splice(edgeIndex, 1);
                updateNodeColors();
              }
            }
          }
          redraw();
        } else if (mode === 'edit') {
          const clickedNode = getNodeAtPosition(x, y);
          if (clickedNode) {
            showEditPanel(clickedNode);
          }
        } else if (mode === 'move') {
          const clickedNode = getNodeAtPosition(x, y);
          if (clickedNode) {
            isDragging = true;
            draggedNode = clickedNode;
            dragStartX = x - clickedNode.x;
            dragStartY = y - clickedNode.y;
            canvas.style.cursor = 'grabbing';
          }
        }
      });

      canvas.addEventListener('mousemove', (e) => {
        if (isPanning) {
          panX = initialPanX + (e.clientX - panStartX);
          panY = initialPanY + (e.clientY - panStartY);
          redraw();
          return;
        }
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        nodes.forEach(node => node.isHighlighted = false);
        edges.forEach(edge => edge.isHighlighted = false);
        if (mode === 'move') {
          if (isDragging && draggedNode) {
            draggedNode.x = x - dragStartX;
            draggedNode.y = y - dragStartY;
            redraw();
          } else {
            const hoveredNode = getNodeAtPosition(x, y);
            if (hoveredNode) {
              hoveredNode.isHighlighted = true;
              canvas.style.cursor = 'grab';
            } else {
              canvas.style.cursor = 'default';
            }
          }
        } else if (mode === 'delete' || mode === 'edit') {
          const hoveredNode = getNodeAtPosition(x, y);
          const hoveredEdge = getEdgeAtPosition(x, y);
          if (hoveredNode) {
            hoveredNode.isHighlighted = true;
          } else if (hoveredEdge && mode === 'delete') {
            hoveredEdge.isHighlighted = true;
          }
        } else if (mode === 'addEdge' && startNode) {
          const hoveredNode = getNodeAtPosition(x, y);
          if (hoveredNode && hoveredNode !== startNode) {
            hoveredNode.isHighlighted = true;
          }
          startNode.isHighlighted = true;
        }
        redraw();
      });

      canvas.addEventListener('mouseup', () => {
        isPanning = false;
        if (mode === 'move') {
          isDragging = false;
          draggedNode = null;
          canvas.style.cursor = 'grab';
        }
      });

      canvas.addEventListener('mouseleave', () => {
        isPanning = false;
        if (mode === 'move') {
          isDragging = false;
          draggedNode = null;
          canvas.style.cursor = 'grab';
        }
      });

      document.getElementById('edit-conditions').addEventListener('click', showConditionsEditor);
      document.getElementById('edit-events').addEventListener('click', showEventsEditor);
      document.getElementById('edit-objectives').addEventListener('click', showObjectivesEditor);

      document.getElementById('add-condition').addEventListener('click', () => {
        const input = document.getElementById('new-condition');
        const condition = input.value.trim();
        if (condition) {
          if (!tempConditions.includes(condition)) {
            tempConditions.push(condition);
            const actualCondition = condition.startsWith('!') ? condition.substring(1) : condition;
            globalConditions.add(actualCondition);
            if (!conditionStates.has(actualCondition)) {
              conditionStates.set(actualCondition, false);
            }
          }
          updateConditionsEditList();
          input.value = '';
        }
      });

      document.getElementById('add-event').addEventListener('click', () => {
        const input = document.getElementById('new-event');
        const event = input.value.trim();
        if (event) {
          tempEvents.push(event);
          updateEventsEditList();
          input.value = '';
        }
      });

      document.getElementById('add-objective').addEventListener('click', () => {
        const input = document.getElementById('new-objective');
        const objective = input.value.trim();
        if (objective) {
          if (!tempObjectives.includes(objective)) {
            tempObjectives.push(objective);
            globalObjectives.add(objective);
          }
          updateObjectivesEditList();
          input.value = '';
        }
      });

      document.getElementById('save-conditions').addEventListener('click', () => {
        if (currentEditingNode) {
          currentEditingNode.conditions = [...tempConditions];
          tempConditions.forEach(condition => globalConditions.add(condition));
          updateConditionsList(currentEditingNode.conditions);
        }
        document.getElementById('conditions-editor').style.display = 'none';
      });

      document.getElementById('save-events').addEventListener('click', () => {
        if (currentEditingNode) {
          currentEditingNode.events = [...tempEvents];
          tempEvents.forEach(event => globalEvents.add(event));
          updateEventsList(currentEditingNode.events);
        }
        document.getElementById('events-editor').style.display = 'none';
      });

      document.getElementById('save-objectives').addEventListener('click', () => {
        if (currentEditingNode) {
          currentEditingNode.objectives = [...tempObjectives];
          tempObjectives.forEach(objective => globalObjectives.add(objective));
          updateObjectivesList(currentEditingNode.objectives);
        }
        document.getElementById('objectives-editor').style.display = 'none';
      });

      document.getElementById('cancel-conditions').addEventListener('click', () => {
        document.getElementById('conditions-editor').style.display = 'none';
      });

      document.getElementById('cancel-events').addEventListener('click', () => {
        document.getElementById('events-editor').style.display = 'none';
      });

      document.getElementById('cancel-objectives').addEventListener('click', () => {
        document.getElementById('objectives-editor').style.display = 'none';
      });

      document.getElementById('new-condition').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          document.getElementById('add-condition').click();
        }
      });

      document.getElementById('new-event').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          document.getElementById('add-event').click();
        }
      });

      document.getElementById('copy-yaml').addEventListener('click', () => {
        const yamlContent = document.getElementById('yaml-content');
        navigator.clipboard.writeText(yamlContent.textContent)
          .catch(err => console.error('Copy failed:', err));
      });

      document.getElementById('close-yaml').addEventListener('click', () => {
        document.getElementById('yaml-display-panel').style.display = 'none';
        document.getElementById('overlay').style.display = 'none';
      });

      conditionManagerBtn.addEventListener('click', () => {
        document.getElementById('condition-manager-panel').style.display = 'block';
        document.getElementById('overlay').style.display = 'block';
        updateConditionManagerPanel();
      });

      document.getElementById('close-condition-manager').addEventListener('click', () => {
        document.getElementById('condition-manager-panel').style.display = 'none';
        document.getElementById('overlay').style.display = 'none';
      });

      function updateConditionManagerPanel() {
        const container = document.getElementById('condition-list');
        container.innerHTML = '';
        const sortedConditions = Array.from(globalConditions).sort();
        sortedConditions.forEach(condition => {
          if (condition.startsWith('!')) return;
          const item = document.createElement('div');
          item.className = 'condition-item';
          const conditionName = document.createElement('span');
          conditionName.textContent = condition;
          const toggleContainer = document.createElement('div');
          toggleContainer.className = 'condition-toggle';
          const toggleButton = document.createElement('button');
          const isTrue = conditionStates.get(condition) === true;
          toggleButton.textContent = isTrue ? 'True' : 'False';
          toggleButton.className = isTrue ? 'true' : 'false';
          toggleButton.addEventListener('click', () => {
            const newState = !conditionStates.get(condition);
            conditionStates.set(condition, newState);
            toggleButton.textContent = newState ? 'True' : 'False';
            toggleButton.className = newState ? 'true' : 'false';
            redraw();
          });
          toggleContainer.appendChild(toggleButton);
          item.appendChild(conditionName);
          item.appendChild(toggleContainer);
          container.appendChild(item);
        });
      }

      function updateNodeReachability() {
        nodes.forEach(node => {
          node.isReachable = true;
        });
        nodes.forEach(node => {
          if (node.conditions.some(condition => {
            if (condition.startsWith('!')) {
              const actualCondition = condition.substring(1);
              return conditionStates.get(actualCondition) === true;
            } else {
              return conditionStates.get(condition) === false;
            }
          })) {
            node.isReachable = false;
          }
        });
        const reachableNodes = new Set();
        const startNodes = nodes.filter(node => {
          return !edges.some(edge => edge.endNode === node);
        });
        const blackStartNodes = startNodes.filter(node => !node.isRed && node.isReachable);
        if (blackStartNodes.length > 1) {
          blackStartNodes.sort((a, b) => (a.orderNumber || Infinity) - (b.orderNumber || Infinity));
          blackStartNodes.slice(1).forEach(node => {
            node.isReachable = false;
          });
        }
        function dfs(node) {
          if (!node.isReachable) return;
          if (reachableNodes.has(node)) return;
          reachableNodes.add(node);
          const childEdges = edges.filter(edge => edge.startNode === node);
          if (childEdges.length > 0) {
            const children = childEdges.map(edge => edge.endNode);
            if (!node.isRed) {
              children.forEach(child => {
                if (child.isReachable) {
                  dfs(child);
                }
              });
            } else {
              const sortedChildren = children
                .filter(child => child.isReachable)
                .sort((a, b) => (a.orderNumber || Infinity) - (b.orderNumber || Infinity));
              if (sortedChildren.length > 0) {
                const selectedChild = sortedChildren[0];
                dfs(selectedChild);
                sortedChildren.slice(1).forEach(child => {
                  child.isReachable = false;
                });
              }
            }
          }
        }
        startNodes.forEach(node => {
          dfs(node);
        });
        nodes.forEach(node => {
          if (!reachableNodes.has(node)) {
            node.isReachable = false;
          }
        });
      }

      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
    });
  </script>
</body>
</html>
