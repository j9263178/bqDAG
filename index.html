<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BetonQuest DAG</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
            line-height: 1.6;
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 0 10px;
        }
        header {
            text-align: center;
            padding: 10px 0;
        }
        .animated-title {
            transition: transform 0.3s ease;
        }
        .animated-title:hover {
            transform: scale(1.1);
        }
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        #graph-container {
            width: 100%;
            height: 700px;
            position: relative;
            margin-top: 10px;
            background: #f8f8f8;
            border-radius: 8px;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        .nav-link {
            display: inline-block;
            margin: 10px;
            padding: 8px 15px;
            background: #007bff;
            color: white;
            text-decoration: none;
            border-radius: 20px;
            transition: background-color 0.3s;
        }

        .nav-link:hover {
            background: #0056b3;
        }

        .controls {
            text-align: center;
            margin: 5px 0;
        }

        .mode-button {
            padding: 6px 12px;
            margin: 0 3px;
            border: none;
            border-radius: 20px;
            background: #6c757d;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s;
            font-size: 14px;
        }

        .mode-button.active {
            background: #28a745;
        }

        .mode-button:hover {
            background: #5a6268;
        }

        .mode-button.active:hover {
            background: #218838;
        }

        #edit-panel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            z-index: 1000;
            width: 400px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .edit-field {
            margin-bottom: 8px;
        }

        .edit-field label {
            display: block;
            margin-bottom: 4px;
            color: #333;
            font-weight: bold;
            font-size: 14px;
        }

        .edit-field input, .edit-field textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
            line-height: 1.4;
        }

        .edit-field textarea {
            height: 60px;
            resize: vertical;
        }

        .edit-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 8px;
        }

        .edit-buttons button {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
            font-size: 12px;
        }

        .save-button {
            background: #28a745;
            color: white;
        }

        .save-button:hover {
            background: #218838;
        }

        .cancel-button {
            background: #dc3545;
            color: white;
        }

        .cancel-button:hover {
            background: #c82333;
        }

        #overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }

        .node-info {
            margin-bottom: 20px;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 6px;
            font-size: 14px;
            border: 1px solid #ddd;
        }

        .node-info h3 {
            margin: 0 0 12px 0;
            color: #333;
            font-size: 16px;
            font-weight: bold;
            border-bottom: 1px solid #ddd;
            padding-bottom: 8px;
        }

        .node-info p {
            margin: 8px 0;
            line-height: 1.4;
        }

        .node-info strong {
            color: #555;
            margin-right: 8px;
        }

        .list-container {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 8px;
            padding: 8px;
        }

        .list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            margin: 4px 0;
            background: #f8f8f8;
            border-radius: 4px;
        }

        .list-item button {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 2px 6px;
            cursor: pointer;
        }

        .list-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .list-controls input {
            flex: 1;
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .add-button {
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
        }

        .list-edit-panel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            z-index: 1001;
            width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .list-edit-panel h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 16px;
        }

        .list-container {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 12px;
            padding: 8px;
        }

        #yaml-display-panel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            z-index: 1001;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
        }

        #yaml-content {
            width: 100%;
            height: 400px;
            margin: 10px 0;
            padding: 10px;
            font-family: monospace;
            white-space: pre;
            overflow: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .copy-button {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }

        .copy-button:hover {
            background: #0056b3;
        }

        .yaml-panel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            z-index: 1001;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            text-align: center;
        }

        .yaml-panel h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 16px;
        }

        .yaml-panel textarea {
            width: calc(100% - 20px);
            height: 400px;
            margin: 10px auto;
            padding: 10px;
            font-family: monospace;
            white-space: pre;
            resize: vertical;
            border: 1px solid #ddd;
            border-radius: 4px;
            display: block;
        }

        .condition-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin: 4px 0;
            background: #f5f5f5;
            border-radius: 4px;
        }

        .condition-toggle {
            display: flex;
            gap: 8px;
        }

        .condition-toggle button {
            padding: 4px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 80px;
        }

        .condition-toggle button.true {
            background: #4CAF50;
            color: white;
        }

        .condition-toggle button.false {
            background: #f44336;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1 style="font-size: 24px; margin: 5px 0;">BetonQuest DAG</h1>
            <p style="margin: 5px 0;">Click canvas to add, drag nodes and create connections! Click nodes in edit mode to edit. Note: black nodes are npc_options, red nodes are player_options.</p>
            <div class="controls">
                <button id="addNodeMode" class="mode-button active">Add Node</button>
                <button id="addEdgeMode" class="mode-button">Add Connection</button>
                <button id="editMode" class="mode-button">Edit Mode</button>
                <button id="moveMode" class="mode-button">Move Mode</button>
                <button id="deleteMode" class="mode-button">Delete Mode</button>
                <button id="exportYaml" class="mode-button" style="background: #007bff;">Export YAML</button>
                <button id="importYamlBtn" class="mode-button" style="background: #e6a800;">Import YAML</button>
                <button id="conditionManagerBtn" class="mode-button" style="background: #9c27b0;">Condition Manager</button>
            </div>
        </header>
        <div id="graph-container">
            <canvas id="graphCanvas"></canvas>
        </div>
    </div>

    <div id="overlay"></div>
    <div id="edit-panel">
        <div class="node-info" style="margin-bottom: 20px; padding: 15px; background: #f5f5f5; border-radius: 6px;">
            <h3 style="margin: 0 0 10px 0; color: #333;">Node Information</h3>
            <div id="node-basic-info"></div>
            <div id="node-connections"></div>
        </div>
        <div class="edit-field">
            <label for="edit-id">Node ID:</label>
            <input type="text" id="edit-id">
        </div>
        <div class="edit-field">
            <label for="edit-text">Text:</label>
            <textarea id="edit-text"></textarea>
        </div>
        <div class="edit-field">
            <label>Conditions List:</label>
            <div id="conditions-list" class="list-container"></div>
            <button id="edit-conditions" class="mode-button">Edit Conditions</button>
        </div>
        <div class="edit-field">
            <label>Events List:</label>
            <div id="events-list" class="list-container"></div>
            <button id="edit-events" class="mode-button">Edit Events</button>
        </div>
        <div class="edit-field">
            <label>Objectives List:</label>
            <div id="objectives-list" class="list-container"></div>
            <button id="edit-objectives" class="mode-button">Edit Objectives</button>
        </div>
        <div class="edit-buttons">
            <button class="save-button" id="save-edit">Save</button>
            <button class="cancel-button" id="cancel-edit">Cancel</button>
        </div>
    </div>

    <div id="conditions-editor" class="list-edit-panel">
        <h3>Edit Conditions List</h3>
        <div id="conditions-edit-list" class="list-container"></div>
        <div class="list-controls">
            <input type="text" id="new-condition" placeholder="Enter new condition">
            <button id="add-condition" class="add-button">Add Condition</button>
        </div>
        <div class="edit-buttons">
            <button class="save-button" id="save-conditions">Confirm</button>
            <button class="cancel-button" id="cancel-conditions">Cancel</button>
        </div>
    </div>

    <div id="events-editor" class="list-edit-panel">
        <h3>Edit Events List</h3>
        <div id="events-edit-list" class="list-container"></div>
        <div class="list-controls">
            <input type="text" id="new-event" placeholder="Enter new event">
            <button id="add-event" class="add-button">Add Event</button>
        </div>
        <div class="edit-buttons">
            <button class="save-button" id="save-events">Confirm</button>
            <button class="cancel-button" id="cancel-events">Cancel</button>
        </div>
    </div>

    <div id="objectives-editor" class="list-edit-panel">
        <h3>Edit Objectives List</h3>
        <div id="objectives-edit-list" class="list-container"></div>
        <div class="list-controls">
            <input type="text" id="new-objective" placeholder="Enter new objective">
            <button id="add-objective" class="add-button">Add Objective</button>
        </div>
        <div class="edit-buttons">
            <button class="save-button" id="save-objectives">Confirm</button>
            <button class="cancel-button" id="cancel-objectives">Cancel</button>
        </div>
    </div>

    <div id="yaml-display-panel">
        <h3>YAML Content</h3>
        <div id="yaml-content"></div>
        <div class="edit-buttons">
            <button class="copy-button" id="copy-yaml">Copy</button>
            <button class="cancel-button" id="close-yaml">Close</button>
        </div>
    </div>

    <div id="yaml-import-panel" class="yaml-panel">
        <h3>Import YAML</h3>
        <textarea id="yaml-import-content" placeholder="Paste YAML content here..."></textarea>
        <div class="edit-buttons">
            <button class="save-button" id="import-yaml-confirm">Import</button>
            <button class="cancel-button" id="import-yaml-cancel">Cancel</button>
        </div>
    </div>

    <div id="condition-manager-panel" class="yaml-panel">
        <h3>Condition Manager</h3>
        <div id="condition-list" class="list-container" style="text-align: left; max-height: 400px;">
        </div>
        <div class="edit-buttons">
            <button class="cancel-button" id="close-condition-manager">Close</button>
        </div>
    </div>

    <script>
        class Node {
            constructor(x, y, radius, label) {
                this.x = x;
                this.y = y;
                this.radius = 40;
                this.label = label;
                this.color = '#4CAF50';
                this.highlightColor = '#81C784';
                this.isHighlighted = false;
                this.text = '';
                this.conditions = [];
                this.events = [];
                this.objectives = [];
                this.isRed = false;
                this.isReachable = true;
                this.orderNumber = 0;
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                if (this.isHighlighted) {
                    ctx.fillStyle = this.isRed ? '#ff7070' : '#666666';
                } else {
                    if (!this.isReachable) {
                        ctx.fillStyle = this.isRed ? '#A57777' : '#888888';
                    } else {
                        ctx.fillStyle = this.isRed ? '#ff0000' : '#000000';
                    }
                }
                ctx.fill();
                ctx.closePath();

                // 繪製ID - 向上移動 8 個像素
                ctx.font = 'bold 18px Arial';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const displayLabel = this.label.length > 5 ? this.label.substring(0, 5) + '...' : this.label;
                ctx.fillText(displayLabel, this.x, this.y - 8);

                // 如果有文本，顯示前10個字
                if (this.text) {
                    ctx.font = '300 12px Arial';
                    const previewText = this.text.substring(0, 10) + (this.text.length > 10 ? '...' : '');
                    
                    const textWidth = ctx.measureText(previewText).width;
                    const maxWidth = this.radius * 2;
                    
                    if (textWidth > maxWidth) {
                        const halfText = previewText.substring(0, Math.floor(previewText.length / 2));
                        const remainingText = previewText.substring(Math.floor(previewText.length / 2));
                        ctx.fillText(halfText, this.x, this.y + 8);
                        ctx.fillText(remainingText, this.x, this.y + 20);
                    } else {
                        ctx.fillText(previewText, this.x, this.y + 12);
                    }
                }
            }

            drawHoverInfo(ctx) {
                // 如果沒有任何事件、目標和條件，就不顯示信息框
                if (this.conditions.length === 0 && this.events.length === 0 && this.objectives.length === 0) {
                    return;
                }

                const padding = 10;
                const lineHeight = 20;
                
                // 計算所需的文本寬度和高度
                ctx.font = '14px Arial';
                
                // 獲取最長的文本寬度
                const maxWidth = Math.max(
                    ctx.measureText('Conditions:').width,
                    ctx.measureText('Events:').width,
                    ctx.measureText('Objectives:').width,
                    ...this.conditions.map(c => ctx.measureText(c).width),
                    ...this.events.map(e => ctx.measureText(e).width),
                    ...this.objectives.map(o => ctx.measureText(o).width)
                );
                
                // 計算信息框的尺寸
                const boxWidth = maxWidth + padding * 3;
                const totalItems = this.conditions.length + this.events.length + this.objectives.length;
                const boxHeight = (totalItems + 3) * lineHeight + padding * 2; // +3 是為了標題行
                
                // 計算信息框的位置（在節點右上方）
                let boxX = this.x + this.radius + padding;
                let boxY = this.y - boxHeight - padding;
                
                // 確保信息框不會超出畫布邊界
                if (boxX + boxWidth > ctx.canvas.width) {
                    boxX = this.x - boxWidth - this.radius - padding;
                }
                if (boxY < 0) {
                    boxY = this.y + this.radius + padding;
                }
                
                // 繪製半透明背景
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
                
                // 繪製文本
                ctx.font = '14px Arial';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                
                let currentY = boxY + padding;
                
                // 繪製條件
                if (this.conditions.length > 0) {
                    ctx.fillText('Conditions:', boxX + padding, currentY);
                    currentY += lineHeight;
                    this.conditions.forEach(condition => {
                        ctx.fillText(condition, boxX + padding * 2, currentY);
                        currentY += lineHeight;
                    });
                }
                
                // 繪製事件
                if (this.events.length > 0) {
                    ctx.fillText('Events:', boxX + padding, currentY);
                    currentY += lineHeight;
                    this.events.forEach(event => {
                        ctx.fillText(event, boxX + padding * 2, currentY);
                        currentY += lineHeight;
                    });
                }
                
                // 繪製目標
                if (this.objectives.length > 0) {
                    ctx.fillText('Objectives:', boxX + padding, currentY);
                    currentY += lineHeight;
                    this.objectives.forEach(objective => {
                        ctx.fillText(objective, boxX + padding * 2, currentY);
                        currentY += lineHeight;
                    });
                }
            }

            isPointInside(x, y) {
                const dx = this.x - x;
                const dy = this.y - y;
                return Math.sqrt(dx * dx + dy * dy) <= this.radius;
            }
        }

        class Edge {
            constructor(startNode, endNode) {
                this.startNode = startNode;
                this.endNode = endNode;
                this.color = '#2196F3';
                this.highlightColor = '#64B5F6';
                this.isHighlighted = false;
            }

            draw(ctx) {
                const headLength = 15;
                const angle = Math.atan2(
                    this.endNode.y - this.startNode.y,
                    this.endNode.x - this.startNode.x
                );

                const endX = this.endNode.x - (this.endNode.radius + 5) * Math.cos(angle);
                const endY = this.endNode.y - (this.endNode.radius + 5) * Math.sin(angle);
                
                const startX = this.startNode.x + (this.startNode.radius + 5) * Math.cos(angle);
                const startY = this.startNode.y + (this.startNode.radius + 5) * Math.sin(angle);

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.strokeStyle = this.isHighlighted ? this.highlightColor : this.color;
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(
                    endX - headLength * Math.cos(angle - Math.PI / 6),
                    endY - headLength * Math.sin(angle - Math.PI / 6)
                );
                ctx.lineTo(
                    endX - headLength * Math.cos(angle + Math.PI / 6),
                    endY - headLength * Math.sin(angle + Math.PI / 6)
                );
                ctx.closePath();
                ctx.fillStyle = this.isHighlighted ? this.highlightColor : this.color;
                ctx.fill();
            }

            isPointNear(x, y, threshold = 5) {
                const startX = this.startNode.x;
                const startY = this.startNode.y;
                const endX = this.endNode.x;
                const endY = this.endNode.y;

                const A = x - startX;
                const B = y - startY;
                const C = endX - startX;
                const D = endY - startY;

                const dot = A * C + B * D;
                const len_sq = C * C + D * D;
                let param = -1;

                if (len_sq !== 0) {
                    param = dot / len_sq;
                }

                let xx, yy;

                if (param < 0) {
                    xx = startX;
                    yy = startY;
                } else if (param > 1) {
                    xx = endX;
                    yy = endY;
                } else {
                    xx = startX + param * C;
                    yy = startY + param * D;
                }

                const dx = x - xx;
                const dy = y - yy;
                const distance = Math.sqrt(dx * dx + dy * dy);

                return distance <= threshold;
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('graphCanvas');
            const ctx = canvas.getContext('2d');
            const nodes = [];
            const edges = [];
            let nextNodeLabel = 1;
            let selectedNode = null;
            let draggedNode = null;
            let mode = 'addNode';
            let startNode = null;

            const editPanel = document.getElementById('edit-panel');
            const overlay = document.getElementById('overlay');
            const editText = document.getElementById('edit-text');
            const editTarget = document.getElementById('edit-target');
            const editId = document.getElementById('edit-id');
            let currentEditingNode = null;

            let tempConditions = [];
            let tempEvents = [];
            let tempObjectives = [];

            // 添加全局條件和事件集合
            const globalConditions = new Set();
            const globalEvents = new Set();
            const globalObjectives = new Set();
            
            // 添加條件狀態管理
            const conditionStates = new Map();

            function showEditPanel(node) {
                currentEditingNode = node;
                
                // 更新節點基本信息
                const nodeInfoDiv = document.getElementById('node-basic-info');
                nodeInfoDiv.innerHTML = `
                    <p><strong>Current ID:</strong>${node.label}</p>
                    <p><strong>Node Color:</strong>${node.isRed ? 'Red' : 'Black'}</p>
                    <p><strong>Order Number:</strong>${node.orderNumber > 0 ? '#' + node.orderNumber : 'None'}</p>
                `;

                // 更新節點連接信息
                const connectionsDiv = document.getElementById('node-connections');
                const outgoingNodes = edges
                    .filter(edge => edge.startNode === node)
                    .map(edge => edge.endNode.label)
                    .join(', ');
                
                connectionsDiv.innerHTML = `
                    <p><strong>Points to:</strong>${outgoingNodes || 'None'}</p>
                `;

                // 設置編輯字段的值
                editId.value = node.label || '';
                editText.value = node.text || '';
                
                // 更新條件列表
                updateConditionsList(node.conditions);
                
                // 更新事件列表
                updateEventsList(node.events);

                // 更新目標列表
                updateObjectivesList(node.objectives);
                
                editPanel.style.display = 'block';
                overlay.style.display = 'block';
            }

            function hideEditPanel() {
                editPanel.style.display = 'none';
                overlay.style.display = 'none';
                currentEditingNode = null;
            }

            function updateConditionsList(conditions) {
                const container = document.getElementById('conditions-list');
                container.innerHTML = conditions.map(condition => `
                    <div class="list-item">
                        <span>${condition}</span>
                    </div>
                `).join('');
            }

            function updateEventsList(events) {
                const container = document.getElementById('events-list');
                container.innerHTML = events.map(event => `
                    <div class="list-item">
                        <span>${event}</span>
                    </div>
                `).join('');
            }

            function updateObjectivesList(objectives) {
                const container = document.getElementById('objectives-list');
                container.innerHTML = objectives.map(objective => `
                    <div class="list-item">
                        <span>${objective}</span>
                    </div>
                `).join('');
            }

            function showConditionsEditor() {
                if (currentEditingNode) {
                    tempConditions = [...currentEditingNode.conditions];
                    updateConditionsEditList();
                    document.getElementById('conditions-editor').style.display = 'block';
                }
            }

            function showEventsEditor() {
                if (currentEditingNode) {
                    tempEvents = [...currentEditingNode.events];
                    updateEventsEditList();
                    document.getElementById('events-editor').style.display = 'block';
                }
            }

            function showObjectivesEditor() {
                if (currentEditingNode) {
                    tempObjectives = [...currentEditingNode.objectives];
                    updateObjectivesEditList();
                    document.getElementById('objectives-editor').style.display = 'block';
                }
            }

            function updateConditionsEditList() {
                const container = document.getElementById('conditions-edit-list');
                container.innerHTML = tempConditions.map((condition, index) => `
                    <div class="list-item">
                        <span>${condition}</span>
                        <button class="delete-condition" data-index="${index}">刪除</button>
                    </div>
                `).join('');
            }

            function updateEventsEditList() {
                const container = document.getElementById('events-edit-list');
                container.innerHTML = tempEvents.map((event, index) => `
                    <div class="list-item">
                        <span>${event}</span>
                        <button class="delete-event" data-index="${index}">刪除</button>
                    </div>
                `).join('');
            }

            function updateObjectivesEditList() {
                const container = document.getElementById('objectives-edit-list');
                container.innerHTML = tempObjectives.map((objective, index) => `
                    <div class="list-item">
                        <span>${objective}</span>
                        <button class="delete-objective" data-index="${index}">刪除</button>
                    </div>
                `).join('');
            }

            // 使用事件委託處理刪除操作
            document.getElementById('conditions-edit-list').addEventListener('click', (e) => {
                if (e.target.classList.contains('delete-condition')) {
                    const index = parseInt(e.target.dataset.index);
                    tempConditions.splice(index, 1);
                    updateConditionsEditList();
                }
            });

            document.getElementById('events-edit-list').addEventListener('click', (e) => {
                if (e.target.classList.contains('delete-event')) {
                    const index = parseInt(e.target.dataset.index);
                    tempEvents.splice(index, 1);
                    updateEventsEditList();
                }
            });

            document.getElementById('objectives-edit-list').addEventListener('click', (e) => {
                if (e.target.classList.contains('delete-objective')) {
                    const index = parseInt(e.target.dataset.index);
                    tempObjectives.splice(index, 1);
                    updateObjectivesEditList();
                }
            });

            document.getElementById('save-edit').addEventListener('click', () => {
                if (currentEditingNode) {
                    const newId = editId.value.trim();
                    
                    // 檢查ID是否已存在
                    const idExists = nodes.some(node => 
                        node !== currentEditingNode && node.label === newId
                    );
                    
                    if (idExists) {
                        alert('This ID is already in use, please use a different ID!');
                        return;
                    }
                    
                    // 更新節點ID和其他屬性
                    currentEditingNode.label = newId;
                    currentEditingNode.text = editText.value;
                    
                    // 如果新ID是數字，更新nextNodeLabel
                    const numId = parseInt(newId);
                    if (!isNaN(numId)) {
                        nextNodeLabel = Math.max(nextNodeLabel, numId + 1);
                    }
                    
                    hideEditPanel();
                    redraw();
                }
            });

            document.getElementById('cancel-edit').addEventListener('click', hideEditPanel);

            const addNodeButton = document.getElementById('addNodeMode');
            const addEdgeButton = document.getElementById('addEdgeMode');
            const editButton = document.getElementById('editMode');
            const moveButton = document.getElementById('moveMode');
            const deleteButton = document.getElementById('deleteMode');
            const exportButton = document.getElementById('exportYaml');
            const importYamlBtn = document.getElementById('importYamlBtn');
            const conditionManagerBtn = document.getElementById('conditionManagerBtn');
            let isDragging = false;
            let dragStartX = 0;
            let dragStartY = 0;

            function setMode(newMode) {
                mode = newMode;
                addNodeButton.classList.toggle('active', mode === 'addNode');
                addEdgeButton.classList.toggle('active', mode === 'addEdge');
                editButton.classList.toggle('active', mode === 'edit');
                moveButton.classList.toggle('active', mode === 'move');
                deleteButton.classList.toggle('active', mode === 'delete');
                startNode = null;
                selectedNode = null;
                draggedNode = null;
                redraw();

                if (mode === 'edit') {
                    canvas.style.cursor = 'pointer';
                } else if (mode === 'move') {
                    canvas.style.cursor = 'grab';
                } else {
                    canvas.style.cursor = 'default';
                }
            }

            addNodeButton.addEventListener('click', () => setMode('addNode'));
            addEdgeButton.addEventListener('click', () => setMode('addEdge'));
            editButton.addEventListener('click', () => setMode('edit'));
            moveButton.addEventListener('click', () => setMode('move'));
            deleteButton.addEventListener('click', () => setMode('delete'));
            conditionManagerBtn.addEventListener('click', () => setMode('conditionManager'));

            function resizeCanvas() {
                const container = document.getElementById('graph-container');
                canvas.width = container.offsetWidth;
                canvas.height = container.offsetHeight;
            }

            function redraw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                updateNodeReachability(); // 在重繪之前更新節點可達性
                
                // 先繪製所有邊
                edges.forEach(edge => edge.draw(ctx));
                
                // 然後繪製所有節點
                nodes.forEach(node => node.draw(ctx));
                
                // 最後繪製懸停信息框
                nodes.forEach(node => {
                    if (node.isHighlighted) {
                        node.drawHoverInfo(ctx);
                    }
                });
            }

            function getNodeAtPosition(x, y) {
                return nodes.find(node => node.isPointInside(x, y));
            }

            function getEdgeAtPosition(x, y) {
                return edges.find(edge => edge.isPointNear(x, y));
            }

            function updateNodeColors() {
                // 首先將所有節點設為黑色
                nodes.forEach(node => {
                    node.isRed = false;
                });

                // 第一輪：檢查被黑色節點指向的節點，將它們設為紅色
                edges.forEach(edge => {
                    if (!edge.startNode.isRed) {
                        edge.endNode.isRed = true;
                    }
                });

                // 第二輪：檢查被紅色節點指向的節點，將它們設為黑色
                edges.forEach(edge => {
                    if (edge.startNode.isRed) {
                        edge.endNode.isRed = false;
                    }
                });

                redraw();
            }

            function generateYaml() {
                let yaml = '';
                
                // 收集所有節點中使用的條件、事件和目標
                const allConditions = new Set();
                const allEvents = new Set();
                const allObjectives = new Set();
                
                nodes.forEach(node => {
                    // 收集條件
                    node.conditions.forEach(condition => {
                        allConditions.add(condition);
                        globalConditions.add(condition);
                    });
                    
                    // 收集事件
                    node.events.forEach(event => {
                        allEvents.add(event);
                        globalEvents.add(event);
                    });

                    // 收集目標
                    node.objectives.forEach(objective => {
                        allObjectives.add(objective);
                        globalObjectives.add(objective);
                    });
                });
                
                // 首先輸出全局條件
                if (allConditions.size > 0) {
                    yaml += 'conditions:\n';
                    Array.from(allConditions).sort().forEach(condition => {
                        yaml += `    ${condition}:\n`;
                    });
                    yaml += '\n';
                }

                // 然後輸出全局事件
                if (allEvents.size > 0) {
                    yaml += 'events:\n';
                    Array.from(allEvents).sort().forEach(event => {
                        yaml += `    ${event}:\n`;
                    });
                    yaml += '\n';
                }

                // 輸出全局目標
                if (allObjectives.size > 0) {
                    yaml += 'objectives:\n';
                    Array.from(allObjectives).sort().forEach(objective => {
                        yaml += `    ${objective}:\n`;
                    });
                    yaml += '\n';
                }
                
                // 找出沒有被指向的節點（first節點）
                const targetedNodes = new Set(edges.map(edge => edge.endNode.label));
                const firstNodes = nodes
                    .filter(node => !targetedNodes.has(node.label))
                    .map(node => node.label)
                    .sort();
                
                // 添加first節點
                if (firstNodes.length > 0) {
                    yaml += `first: '${firstNodes.join(',')}'\n\n`;
                }

                // 分類NPC和玩家選項
                const npcNodes = nodes.filter(node => !node.isRed);
                const playerNodes = nodes.filter(node => node.isRed);

                // 修改NPC選項的YAML生成
                yaml += 'NPC_options:\n';
                npcNodes.forEach(node => {
                    yaml += `  ${node.label}:\n`;
                    if (node.text) {
                        // 檢查是否為單行文本（不包含換行符）
                        if (!node.text.includes('\n')) {
                            yaml += `    text: '${node.text}'\n`;
                        } else {
                            yaml += `    text: |-\n`;
                            // 處理多行文本，每行都要加縮排
                            const lines = node.text.split('\n');
                            lines.forEach(line => {
                                yaml += `      ${line}\n`;
                            });
                        }
                    }
                    if (node.conditions.length > 0) {
                        yaml += `    conditions: '${node.conditions.join(',')}'\n`;
                    }
                    if (node.events.length > 0) {
                        yaml += `    events: '${node.events.join(',')}'\n`;
                    }
                    if (node.objectives.length > 0) {
                        yaml += `    objectives: '${node.objectives.join(',')}'\n`;
                    }
                    
                    // 處理指向的節點
                    const pointers = edges
                        .filter(edge => edge.startNode === node)
                        .map(edge => edge.endNode.label);
                    
                    if (pointers.length > 0) {
                        yaml += `    pointer: '${pointers.join(',')}'\n`;
                    }
                });

                // 修改玩家選項的YAML生成
                yaml += '\nplayer_options:\n';
                playerNodes.forEach(node => {
                    yaml += `  ${node.label}:\n`;
                    if (node.text) {
                        // 檢查是否為單行文本（不包含換行符）
                        if (!node.text.includes('\n')) {
                            yaml += `    text: '${node.text}'\n`;
                        } else {
                            yaml += `    text: |-\n`;
                            // 處理多行文本，每行都要加縮排
                            const lines = node.text.split('\n');
                            lines.forEach(line => {
                                yaml += `      ${line}\n`;
                            });
                        }
                    }
                    if (node.conditions.length > 0) {
                        yaml += `    conditions: '${node.conditions.join(',')}'\n`;
                    }
                    if (node.events.length > 0) {
                        yaml += `    events: '${node.events.join(',')}'\n`;
                    }
                    if (node.objectives.length > 0) {
                        yaml += `    objectives: '${node.objectives.join(',')}'\n`;
                    }
                    
                    // 處理指向的節點
                    const pointers = edges
                        .filter(edge => edge.startNode === node)
                        .map(edge => edge.endNode.label);
                    
                    if (pointers.length > 0) {
                        yaml += `    pointer: '${pointers.join(',')}'\n`;
                    }
                });

                // 顯示 YAML 內容
                const yamlContent = document.getElementById('yaml-content');
                yamlContent.textContent = yaml;
                document.getElementById('yaml-display-panel').style.display = 'block';
                document.getElementById('overlay').style.display = 'block';
            }

            function parseYamlContent(content) {
                try {
                    const lines = content.split('\n');
                    const nodes = new Map();
                    const connections = [];
                    let currentNode = null;
                    let currentSection = null;
                    let isReadingText = false;
                    let currentText = [];
                    
                    // 清空全局集合和條件狀態
                    globalConditions.clear();
                    globalEvents.clear();
                    globalObjectives.clear();
                    conditionStates.clear();
                    
                    for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                        try {
                            const line = lines[lineIndex];
                            const trimmedLine = line.trim();
                            
                            // 處理全局條件
                            if (trimmedLine === 'conditions:') {
                                if (isReadingText && currentText.length > 0 && currentNode) {
                                    nodes.get(currentNode).text = currentText.join('\n');
                                    isReadingText = false;
                                    currentText = [];
                                }
                                currentSection = 'conditions';
                                continue;
                            }
                            // 處理全局事件
                            else if (trimmedLine === 'events:') {
                                if (isReadingText && currentText.length > 0 && currentNode) {
                                    nodes.get(currentNode).text = currentText.join('\n');
                                    isReadingText = false;
                                    currentText = [];
                                }
                                currentSection = 'events';
                                continue;
                            }
                            // 處理全局目標
                            else if (trimmedLine === 'objectives:') {
                                if (isReadingText && currentText.length > 0 && currentNode) {
                                    nodes.get(currentNode).text = currentText.join('\n');
                                    isReadingText = false;
                                    currentText = [];
                                }
                                currentSection = 'objectives';
                                continue;
                            }
                            // 收集全局條件
                            else if (currentSection === 'conditions' && trimmedLine.endsWith(':')) {
                                const condition = trimmedLine.slice(0, -1).trim();
                                if (!condition) {
                                    throw new Error('條件名稱不能為空');
                                }
                                globalConditions.add(condition);
                            }
                            // 收集全局事件
                            else if (currentSection === 'events' && trimmedLine.endsWith(':')) {
                                const event = trimmedLine.slice(0, -1).trim();
                                if (!event) {
                                    throw new Error('事件名稱不能為空');
                                }
                                globalEvents.add(event);
                            }
                            // 收集全局目標
                            else if (currentSection === 'objectives' && trimmedLine.endsWith(':')) {
                                const objective = trimmedLine.slice(0, -1).trim();
                                if (!objective) {
                                    throw new Error('目標名稱不能為空');
                                }
                                globalObjectives.add(objective);
                            }
                            // 處理 first 節點
                            else if (trimmedLine.startsWith('first:')) {
                                if (isReadingText && currentText.length > 0 && currentNode) {
                                    nodes.get(currentNode).text = currentText.join('\n');
                                    isReadingText = false;
                                    currentText = [];
                                }
                                // 支持帶引號和不帶引號的格式
                                const match = trimmedLine.match(/first:\s*'?([^']*)'?$/);
                                if (!match) {
                                    throw new Error('first 節點格式錯誤');
                                }
                                const firstValue = match[1];
                                if (firstValue) {
                                    firstValue.split(',').forEach(nodeId => {
                                        if (!nodeId.trim()) {
                                            throw new Error('first 節點ID不能為空');
                                        }
                                        if (!nodes.has(nodeId)) {
                                            nodes.set(nodeId, {
                                                text: '',
                                                conditions: [],
                                                events: [],
                                                pointers: []
                                            });
                                        }
                                    });
                                }
                            }
                            // 處理主要部分
                            else if (trimmedLine === 'NPC_options:') {
                                if (isReadingText && currentText.length > 0 && currentNode) {
                                    nodes.get(currentNode).text = currentText.join('\n');
                                    isReadingText = false;
                                    currentText = [];
                                }
                                currentSection = 'NPC_options';
                                isReadingText = false;
                            }
                            else if (trimmedLine === 'player_options:') {
                                if (isReadingText && currentText.length > 0 && currentNode) {
                                    nodes.get(currentNode).text = currentText.join('\n');
                                    isReadingText = false;
                                    currentText = [];
                                }
                                currentSection = 'player_options';
                                isReadingText = false;
                            }
                            // 處理節點定義
                            else if (trimmedLine.match(/^[^:]+:$/)) {
                                if (isReadingText && currentText.length > 0 && currentNode) {
                                    nodes.get(currentNode).text = currentText.join('\n');
                                    isReadingText = false;
                                    currentText = [];
                                }
                                if (!currentSection) {
                                    throw new Error('節點必須在 NPC_options 或 player_options 區塊內');
                                }
                                currentNode = trimmedLine.slice(0, -1);
                                if (!currentNode.trim()) {
                                    throw new Error('節點ID不能為空');
                                }
                                if (!nodes.has(currentNode)) {
                                    nodes.set(currentNode, {
                                        text: '',
                                        conditions: [],
                                        events: [],
                                        pointers: []
                                    });
                                }
                                isReadingText = false;
                                currentText = [];
                            }
                            // 處理文本開始
                            else if (trimmedLine.startsWith('text:')) {
                                if (!currentNode) {
                                    throw new Error('text 必須在節點定義內');
                                }
                                // 檢查是否是單行文本格式
                                if (trimmedLine === 'text: |-') {
                                    // 多行文本格式
                                    isReadingText = true;
                                    currentText = [];
                                } else {
                                    // 單行文本格式，支持帶引號和不帶引號
                                    const singleLineMatch = trimmedLine.match(/^text:\s*'?([^']*)'?$/);
                                    if (singleLineMatch) {
                                        nodes.get(currentNode).text = singleLineMatch[1];
                                        isReadingText = false;
                                        currentText = [];
                                    } else {
                                        throw new Error('text 格式錯誤，應為：text: \'內容\' 或 text: |-');
                                    }
                                }
                            }
                            // 處理條件
                            else if (trimmedLine.startsWith('conditions:')) {
                                if (isReadingText && currentText.length > 0 && currentNode) {
                                    nodes.get(currentNode).text = currentText.join('\n');
                                    isReadingText = false;
                                    currentText = [];
                                }
                                if (!currentNode) {
                                    throw new Error('conditions 必須在節點定義內');
                                }
                                // 支持帶引號和不帶引號的格式
                                const match = trimmedLine.match(/conditions:\s*'?([^']*)'?$/);
                                if (!match) {
                                    throw new Error('conditions 格式錯誤');
                                }
                                const conditionsStr = match[1];
                                if (conditionsStr) {
                                    nodes.get(currentNode).conditions = conditionsStr.split(',');
                                }
                            }
                            // 處理事件
                            else if (trimmedLine.startsWith('events:')) {
                                if (isReadingText && currentText.length > 0 && currentNode) {
                                    nodes.get(currentNode).text = currentText.join('\n');
                                    isReadingText = false;
                                    currentText = [];
                                }
                                if (!currentNode) {
                                    throw new Error('events 必須在節點定義內');
                                }
                                // 支持帶引號和不帶引號的格式
                                const match = trimmedLine.match(/events:\s*'?([^']*)'?$/);
                                if (!match) {
                                    throw new Error('events 格式錯誤');
                                }
                                const eventsStr = match[1];
                                if (eventsStr) {
                                    nodes.get(currentNode).events = eventsStr.split(',');
                                }
                            }
                            // 處理目標
                            else if (trimmedLine.startsWith('objectives:')) {
                                if (isReadingText && currentText.length > 0 && currentNode) {
                                    nodes.get(currentNode).text = currentText.join('\n');
                                    isReadingText = false;
                                    currentText = [];
                                }
                                if (!currentNode) {
                                    throw new Error('objectives 必須在節點定義內');
                                }
                                // 支持帶引號和不帶引號的格式
                                const match = trimmedLine.match(/objectives:\s*'?([^']*)'?$/);
                                if (!match) {
                                    throw new Error('objectives 格式錯誤');
                                }
                                const objectivesStr = match[1];
                                if (objectivesStr) {
                                    nodes.get(currentNode).objectives = objectivesStr.split(',');
                                }
                            }
                            // 處理指針
                            else if (trimmedLine.startsWith('pointer:')) {
                                if (isReadingText && currentText.length > 0 && currentNode) {
                                    nodes.get(currentNode).text = currentText.join('\n');
                                    isReadingText = false;
                                    currentText = [];
                                }
                                if (!currentNode) {
                                    throw new Error('pointer 必須在節點定義內');
                                }
                                // 支持帶引號和不帶引號的格式
                                const match = trimmedLine.match(/pointer:\s*'?([^']*)'?$/);
                                if (!match) {
                                    throw new Error('pointer 格式錯誤');
                                }
                                const pointerStr = match[1];
                                if (pointerStr) {
                                    const pointers = pointerStr.split(',');
                                    nodes.get(currentNode).pointers = pointers;
                                    pointers.forEach(pointer => {
                                        if (!pointer.trim()) {
                                            throw new Error('pointer 不能包含空值');
                                        }
                                        connections.push([currentNode, pointer]);
                                    });
                                }
                            }
                            // 處理多行文本內容
                            else if (isReadingText && line.startsWith('      ')) {
                                currentText.push(line.substring(6));
                            }
                            // 如果下一行不是以六個空格開頭且不是空行，且我們正在讀取文本，則保存當前文本
                            else if (isReadingText && currentText.length > 0 && 
                                    (!lines[lineIndex + 1] || 
                                     (!lines[lineIndex + 1].startsWith('      ') && lines[lineIndex + 1].trim()))) {
                                nodes.get(currentNode).text = currentText.join('\n');
                                isReadingText = false;
                                currentText = [];
                            }
                            // 如果是最後一行，保存當前文本
                            else if (lineIndex === lines.length - 1 && isReadingText && currentText.length > 0 && currentNode) {
                                nodes.get(currentNode).text = currentText.join('\n');
                                isReadingText = false;
                            }
                        } catch (error) {
                            throw new Error(`第 ${lineIndex + 1} 行出錯：${error.message}\n問題行內容：${lines[lineIndex]}`);
                        }
                    }

                    return { nodes, connections };
                } catch (error) {
                    alert(error.message);
                    console.error('YAML解析錯誤:', error);
                    return null;
                }
            }

            function importYaml(content) {
                const data = parseYamlContent(content);
                if (!data) {
                    alert('YAML格式錯誤！');
                    return;
                }

                // 清空現有圖形
                nodes.length = 0;
                edges.length = 0;

                // 根據文本內容對節點進行排序
                const sortedNodes = Array.from(data.nodes.entries()).sort((a, b) => {
                    const textA = a[1].text || '';
                    const textB = b[1].text || '';
                    return textA.localeCompare(textB, 'zh-TW');
                });

                // 創建所有節點，設置位置和順序編號
                sortedNodes.forEach(([nodeId, nodeData], index) => {
                    const node = new Node(0, 0, 40, nodeId);
                    node.text = nodeData.text;
                    node.conditions = nodeData.conditions;
                    node.events = nodeData.events;
                    node.orderNumber = index + 1; // 設置順序編號，從1開始
                    nodes.push(node);
                });

                // 創建連接
                data.connections.forEach(([fromId, toId]) => {
                    const startNode = nodes.find(n => n.label === fromId);
                    const endNode = nodes.find(n => n.label === toId);
                    if (startNode && endNode) {
                        edges.push(new Edge(startNode, endNode));
                    }
                });

                // 找出根節點（沒有被指向的節點）
                const targetedNodes = new Set(edges.map(edge => edge.endNode.label));
                const rootNodes = nodes.filter(node => !targetedNodes.has(node.label));

                // 計算每個節點的層級
                const nodeLevels = new Map();
                const calculateLevels = (node, level) => {
                    if (nodeLevels.has(node)) {
                        return;
                    }
                    nodeLevels.set(node, level);
                    const children = edges
                        .filter(edge => edge.startNode === node)
                        .map(edge => edge.endNode);
                    children.forEach(child => calculateLevels(child, level + 1));
                };
                rootNodes.forEach(node => calculateLevels(node, 0));

                // 按層級分組節點
                const levelGroups = new Map();
                nodeLevels.forEach((level, node) => {
                    if (!levelGroups.has(level)) {
                        levelGroups.set(level, []);
                    }
                    levelGroups.get(level).push(node);
                });

                // 計算最大層級數和每層最大節點數
                const maxLevel = Math.max(...nodeLevels.values());
                const maxNodesInLevel = Math.max(...Array.from(levelGroups.values()).map(group => group.length));

                // 設置布局參數
                const levelSpacing = canvas.width / (maxLevel + 2); // 層級之間的間距
                const nodeSpacing = canvas.height / (maxNodesInLevel + 1); // 同層節點之間的間距
                const startX = levelSpacing; // 起始X座標

                // 設置節點位置
                levelGroups.forEach((nodesInLevel, level) => {
                    const levelX = startX + level * levelSpacing;
                    const totalHeight = (nodesInLevel.length - 1) * nodeSpacing;
                    const startY = (canvas.height - totalHeight) / 2;

                    nodesInLevel.forEach((node, index) => {
                        node.x = levelX;
                        node.y = startY + index * nodeSpacing;
                    });
                });

                // 更新節點顏色
                updateNodeColors();

                // 初始化所有條件的狀態為 false
                nodes.forEach(node => {
                    node.conditions.forEach(condition => {
                        // 如果是否定條件，獲取原始條件名稱
                        const actualCondition = condition.startsWith('!') ? condition.substring(1) : condition;
                        // 將條件添加到全局條件集合
                        globalConditions.add(actualCondition);
                        // 設置條件狀態為 false
                        conditionStates.set(actualCondition, false);
                    });
                });

                // 更新節點可達性
                updateNodeReachability();
                redraw();

                // 更新條件管理面板
                updateConditionManagerPanel();

                // 更新下一個節點的標籤
                nextNodeLabel = Math.max(...Array.from(data.nodes.keys()).map(id => parseInt(id) || 0)) + 1;
            }

            // 修改導入按鈕的事件監聽器
            document.getElementById('importYamlBtn').addEventListener('click', () => {
                document.getElementById('yaml-import-panel').style.display = 'block';
                document.getElementById('overlay').style.display = 'block';
                document.getElementById('yaml-import-content').value = '';  // 清空文本區域
            });

            // 添加導入確認按鈕的事件監聽器
            document.getElementById('import-yaml-confirm').addEventListener('click', () => {
                const content = document.getElementById('yaml-import-content').value;
                if (content.trim()) {
                    importYaml(content);
                    document.getElementById('yaml-import-panel').style.display = 'none';
                    document.getElementById('overlay').style.display = 'none';
                } else {
                    alert('Please paste YAML content first!');
                }
            });

            // 添加導入取消按鈕的事件監聽器
            document.getElementById('import-yaml-cancel').addEventListener('click', () => {
                document.getElementById('yaml-import-panel').style.display = 'none';
                document.getElementById('overlay').style.display = 'none';
            });

            exportButton.addEventListener('click', generateYaml);

            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (mode === 'addNode') {
                    const node = new Node(x, y, 40, nextNodeLabel.toString());
                    nodes.push(node);
                    nextNodeLabel++;
                    updateNodeColors();
                } else if (mode === 'addEdge') {
                    const clickedNode = getNodeAtPosition(x, y);
                    if (clickedNode) {
                        if (!startNode) {
                            startNode = clickedNode;
                            startNode.isHighlighted = true;
                        } else if (startNode !== clickedNode) {
                            const edgeExists = edges.some(edge => 
                                edge.startNode === startNode && edge.endNode === clickedNode
                            );
                            if (!edgeExists) {
                                edges.push(new Edge(startNode, clickedNode));
                                updateNodeColors();
                            }
                            startNode.isHighlighted = false;
                            startNode = null;
                        }
                        redraw();
                    }
                } else if (mode === 'delete') {
                    const clickedNode = getNodeAtPosition(x, y);
                    if (clickedNode) {
                        const nodeIndex = nodes.indexOf(clickedNode);
                        if (nodeIndex > -1) {
                            nodes.splice(nodeIndex, 1);
                            for (let i = edges.length - 1; i >= 0; i--) {
                                if (edges[i].startNode === clickedNode || edges[i].endNode === clickedNode) {
                                    edges.splice(i, 1);
                                }
                            }
                            updateNodeColors();
                        }
                    } else {
                        const clickedEdge = getEdgeAtPosition(x, y);
                        if (clickedEdge) {
                            const edgeIndex = edges.indexOf(clickedEdge);
                            if (edgeIndex > -1) {
                                edges.splice(edgeIndex, 1);
                                updateNodeColors();
                            }
                        }
                    }
                    redraw();
                } else if (mode === 'edit') {
                    const clickedNode = getNodeAtPosition(x, y);
                    if (clickedNode) {
                        showEditPanel(clickedNode);
                    }
                } else if (mode === 'move') {
                    const clickedNode = getNodeAtPosition(x, y);
                    if (clickedNode) {
                        isDragging = true;
                        draggedNode = clickedNode;
                        dragStartX = x - clickedNode.x;
                        dragStartY = y - clickedNode.y;
                        canvas.style.cursor = 'grabbing';
                    }
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                nodes.forEach(node => node.isHighlighted = false);
                edges.forEach(edge => edge.isHighlighted = false);

                if (mode === 'move') {
                    if (isDragging && draggedNode) {
                        draggedNode.x = x - dragStartX;
                        draggedNode.y = y - dragStartY;
                        redraw();
                    } else {
                        const hoveredNode = getNodeAtPosition(x, y);
                        if (hoveredNode) {
                            hoveredNode.isHighlighted = true;
                            canvas.style.cursor = 'grab';
                        } else {
                            canvas.style.cursor = 'default';
                        }
                    }
                } else if (mode === 'delete' || mode === 'edit') {
                    const hoveredNode = getNodeAtPosition(x, y);
                    const hoveredEdge = getEdgeAtPosition(x, y);
                    if (hoveredNode) {
                        hoveredNode.isHighlighted = true;
                    } else if (hoveredEdge && mode === 'delete') {
                        hoveredEdge.isHighlighted = true;
                    }
                } else if (mode === 'addEdge' && startNode) {
                    const hoveredNode = getNodeAtPosition(x, y);
                    if (hoveredNode && hoveredNode !== startNode) {
                        hoveredNode.isHighlighted = true;
                    }
                    startNode.isHighlighted = true;
                }

                redraw();
            });

            canvas.addEventListener('mouseup', () => {
                if (mode === 'move') {
                    isDragging = false;
                    draggedNode = null;
                    canvas.style.cursor = 'grab';
                }
            });

            canvas.addEventListener('mouseleave', () => {
                if (mode === 'move') {
                    isDragging = false;
                    draggedNode = null;
                    canvas.style.cursor = 'grab';
                }
            });

            // 使用事件監聽器綁定按鈕點擊事件
            document.getElementById('edit-conditions').addEventListener('click', showConditionsEditor);
            document.getElementById('edit-events').addEventListener('click', showEventsEditor);
            document.getElementById('edit-objectives').addEventListener('click', showObjectivesEditor);

            // 添加條件按鈕事件監聽器
            document.getElementById('add-condition').addEventListener('click', () => {
                const input = document.getElementById('new-condition');
                const condition = input.value.trim();
                if (condition) {
                    // 直接添加條件，保持原始格式（包括"!"）
                    if (!tempConditions.includes(condition)) {
                        tempConditions.push(condition);
                        // 無論是否為否定條件，都只添加原始條件（不帶!）到全局條件集合
                        const actualCondition = condition.startsWith('!') ? condition.substring(1) : condition;
                        globalConditions.add(actualCondition);
                        if (!conditionStates.has(actualCondition)) {
                            conditionStates.set(actualCondition, false);
                        }
                    }
                    updateConditionsEditList();
                    input.value = '';
                }
            });

            // 添加事件按鈕事件監聽器
            document.getElementById('add-event').addEventListener('click', () => {
                const input = document.getElementById('new-event');
                const event = input.value.trim();
                if (event) {
                    tempEvents.push(event);
                    updateEventsEditList();
                    input.value = '';
                }
            });

            // 添加目標按鈕事件監聽器
            document.getElementById('add-objective').addEventListener('click', () => {
                const input = document.getElementById('new-objective');
                const objective = input.value.trim();
                if (objective) {
                    if (!tempObjectives.includes(objective)) {
                        tempObjectives.push(objective);
                        globalObjectives.add(objective);
                    }
                    updateObjectivesEditList();
                    input.value = '';
                }
            });

            // 修改保存條件的處理器
            document.getElementById('save-conditions').addEventListener('click', () => {
                if (currentEditingNode) {
                    currentEditingNode.conditions = [...tempConditions];
                    // 添加到全局條件集合
                    tempConditions.forEach(condition => globalConditions.add(condition));
                    updateConditionsList(currentEditingNode.conditions);
                }
                document.getElementById('conditions-editor').style.display = 'none';
            });

            // 修改保存事件的處理器
            document.getElementById('save-events').addEventListener('click', () => {
                if (currentEditingNode) {
                    currentEditingNode.events = [...tempEvents];
                    // 添加到全局事件集合
                    tempEvents.forEach(event => globalEvents.add(event));
                    updateEventsList(currentEditingNode.events);
                }
                document.getElementById('events-editor').style.display = 'none';
            });

            // 修改保存目標的處理器
            document.getElementById('save-objectives').addEventListener('click', () => {
                if (currentEditingNode) {
                    currentEditingNode.objectives = [...tempObjectives];
                    // 添加到全局目標集合
                    tempObjectives.forEach(objective => globalObjectives.add(objective));
                    updateObjectivesList(currentEditingNode.objectives);
                }
                document.getElementById('objectives-editor').style.display = 'none';
            });

            // 取消條件編輯按鈕事件監聽器
            document.getElementById('cancel-conditions').addEventListener('click', () => {
                document.getElementById('conditions-editor').style.display = 'none';
            });

            // 取消事件編輯按鈕事件監聽器
            document.getElementById('cancel-events').addEventListener('click', () => {
                document.getElementById('events-editor').style.display = 'none';
            });

            // 取消目標編輯按鈕事件監聽器
            document.getElementById('cancel-objectives').addEventListener('click', () => {
                document.getElementById('objectives-editor').style.display = 'none';
            });

            // 添加回車鍵提交功能
            document.getElementById('new-condition').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('add-condition').click();
                }
            });

            document.getElementById('new-event').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('add-event').click();
                }
            });

            // 修改複製按鈕的事件監聽器
            document.getElementById('copy-yaml').addEventListener('click', () => {
                const yamlContent = document.getElementById('yaml-content');
                navigator.clipboard.writeText(yamlContent.textContent)
                    .catch(err => console.error('Copy failed:', err));
            });

            document.getElementById('close-yaml').addEventListener('click', () => {
                document.getElementById('yaml-display-panel').style.display = 'none';
                document.getElementById('overlay').style.display = 'none';
            });

            // 修改條件管理按鈕的事件處理
            conditionManagerBtn.addEventListener('click', () => {
                document.getElementById('condition-manager-panel').style.display = 'block';
                document.getElementById('overlay').style.display = 'block';
                updateConditionManagerPanel();
            });

            // 添加關閉按鈕的事件處理
            document.getElementById('close-condition-manager').addEventListener('click', () => {
                document.getElementById('condition-manager-panel').style.display = 'none';
                document.getElementById('overlay').style.display = 'none';
            });

            function updateConditionManagerPanel() {
                const container = document.getElementById('condition-list');
                container.innerHTML = '';
                
                // 只顯示原始條件（不包含"!"的條件）
                const sortedConditions = Array.from(globalConditions).sort();
                
                sortedConditions.forEach(condition => {
                    // 跳過以"!"開頭的條件
                    if (condition.startsWith('!')) return;
                    
                    const item = document.createElement('div');
                    item.className = 'condition-item';
                    
                    const conditionName = document.createElement('span');
                    conditionName.textContent = condition;
                    
                    const toggleContainer = document.createElement('div');
                    toggleContainer.className = 'condition-toggle';
                    
                    const toggleButton = document.createElement('button');
                    const isTrue = conditionStates.get(condition) === true;
                    toggleButton.textContent = isTrue ? 'True' : 'False';
                    toggleButton.className = isTrue ? 'true' : 'false';
                    
                    toggleButton.addEventListener('click', () => {
                        const newState = !conditionStates.get(condition);
                        conditionStates.set(condition, newState);
                        toggleButton.textContent = newState ? 'True' : 'False';
                        toggleButton.className = newState ? 'true' : 'false';
                        redraw(); // 更新節點顯示
                    });
                    
                    toggleContainer.appendChild(toggleButton);
                    
                    item.appendChild(conditionName);
                    item.appendChild(toggleContainer);
                    container.appendChild(item);
                });
            }

            function updateNodeReachability() {
                // 重置所有節點的可達性
                nodes.forEach(node => {
                    node.isReachable = true;
                });

                // 檢查條件
                nodes.forEach(node => {
                    if (node.conditions.some(condition => {
                        if (condition.startsWith('!')) {
                            const actualCondition = condition.substring(1);
                            return conditionStates.get(actualCondition) === true; // 如果條件為 true，則否定條件不滿足
                        } else {
                            return conditionStates.get(condition) === false; // 如果條件為 false，則條件不滿足
                        }
                    })) {
                        node.isReachable = false;
                    }
                });

                // 檢查是否有路徑可以到達
                const reachableNodes = new Set();
                
                // 找出所有沒有入邊的節點（起始節點）
                const startNodes = nodes.filter(node => {
                    return !edges.some(edge => edge.endNode === node);
                });

                // 對於沒有被指向的黑色節點，只保留順序編號最小的為可達
                const blackStartNodes = startNodes.filter(node => !node.isRed && node.isReachable);
                if (blackStartNodes.length > 1) {
                    // 按順序編號排序
                    blackStartNodes.sort((a, b) => (a.orderNumber || Infinity) - (b.orderNumber || Infinity));
                    // 除了第一個（順序編號最小的）之外，其他都標記為不可達
                    blackStartNodes.slice(1).forEach(node => {
                        node.isReachable = false;
                    });
                }

                // 使用 DFS 遍歷所有可達節點，並記錄選擇的路徑
                function dfs(node) {
                    if (!node.isReachable) return; // 如果節點因條件而不可達，停止遍歷
                    if (reachableNodes.has(node)) return;
                    reachableNodes.add(node);
                    
                    // 獲取所有子節點
                    const childEdges = edges.filter(edge => edge.startNode === node);
                    if (childEdges.length > 0) {
                        // 獲取所有子節點
                        const children = childEdges.map(edge => edge.endNode);
                        
                        if (!node.isRed) {
                            // 黑色節點（NPC 選項）：所有滿足條件的子節點都可達
                            children.forEach(child => {
                                if (child.isReachable) { // 如果子節點滿足自己的條件
                                    dfs(child);
                                }
                            });
                        } else {
                            // 紅色節點（玩家選項）：按照順序編號排序，只有最小編號的可達
                            const sortedChildren = children
                                .filter(child => child.isReachable)
                                .sort((a, b) => (a.orderNumber || Infinity) - (b.orderNumber || Infinity));

                            if (sortedChildren.length > 0) {
                                // 只遍歷順序編號最小的子節點
                                const selectedChild = sortedChildren[0];
                                dfs(selectedChild);
                                
                                // 其他子節點標記為不可達
                                sortedChildren.slice(1).forEach(child => {
                                    child.isReachable = false;
                                });
                            }
                        }
                    }
                }

                // 從每個起始節點開始遍歷
                startNodes.forEach(node => {
                    dfs(node);
                });

                // 更新節點的可達性
                nodes.forEach(node => {
                    if (!reachableNodes.has(node)) {
                        node.isReachable = false;
                    }
                });
            }

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        });
    </script>
</body>
</html> 